<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Grapher — Chart en page / Contrôles en sheet (Stock)</title>

  <!-- Framework7 + Highcharts Stock -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/framework7@8.3.4/framework7-bundle.min.css" />
  <script src="https://cdn.jsdelivr.net/npm/framework7@8.3.4/framework7-bundle.min.js"></script>
  <script src="https://code.highcharts.com/stock/highstock.js"></script>

  <style>
    :root { --nav-h: var(--f7-navbar-height, 44px); }

    /* Graph: 100% largeur et ne dépasse jamais l'écran (navigator inclus) */
    #chart-container {
      width: 100%;
      height: calc(100vh - var(--nav-h));
      max-height: calc(100vh - var(--nav-h));
    }

    /* Sheet en 2 étapes + push view ; handle indicatif */
    #controls-sheet { height: auto; max-height: 100vh; }
    #controls-sheet .sheet-modal-swipe-step { min-height: 92px; }
    .sheet-handle { height: 20px; display:flex; align-items:center; justify-content:center; }
    .sheet-handle::before { content:""; width:36px; height:4px; border-radius:2px; background:#999; opacity:.6; }

    /* Quand la sheet est en plein écran, son contenu reste scollable et borné à 100vh */
    #controls-sheet .sheet-modal-inner {
      max-height: calc(100vh - 20px); /* 20px ≈ handle */
      overflow: auto;
    }

    /* Mise en forme rapide des contrôles */
    .ctrls .list input,
    .ctrls .list select,
    .ctrls .list textarea { width: 100%; }
    .ctrls .button-row { display: flex; gap: 8px; flex-wrap: wrap; }
    .ctrls .button-row .button { flex: 1; min-width: 120px; }
    .ctrls textarea {
      min-height: 160px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      font-size: 12px;
    }
    .muted { color: var(--f7-text-muted); font-size: 12px; }

    /* Navbar cachée en orientation paysage */
    @media (orientation: landscape) {
      .navbar { display: none !important; }
      :root { --nav-h: 0px; }
    }
  </style>
</head>
<body>
<div id="app">
  <div class="view view-main view-init" data-url="/">
    <div class="page">
      <div class="navbar">
        <div class="navbar-bg"></div>
        <div class="navbar-inner">
          <div class="title">Grapher (Stock)</div>
          <div class="right"><a href="#" class="link" id="openControls">Contrôles</a></div>
        </div>
      </div>

      <div class="page-content">
        <!-- ICI: LE GRAPH UNIQUEMENT -->
        <div id="chart-container"></div>
      </div>
    </div>
  </div>

  <!-- SHEET = CONTRÔLES -->
  <div class="sheet-modal sheet-modal-push" id="controls-sheet">
    <div class="sheet-handle"></div>
    <div class="sheet-modal-inner">
      <!-- Étape compacte visible en bas -->
      <div class="sheet-modal-swipe-step">
        <div class="block no-margin">
          <p class="no-margin text-color-gray">
            Contrôles — swipe/tap pour agrandir ⤴︎
          </p>
        </div>
      </div>

      <!-- Contenu contrôles -->
      <div class="block crtls">
        <div class="list inset">
          <ul>
            <li class="item-content item-input">
              <div class="item-inner">
                <div class="item-title item-label">Type de série</div>
                <div class="item-input-wrap">
                  <select id="seriesType">
                    <option value="spline" selected>Spline</option>
                    <option value="line">Line</option>
                    <option value="area">Area</option>
                    <option value="areaspline">Area Spline</option>
                    <option value="column">Column</option>
                    <option value="scatter">Scatter</option>
                  </select>
                </div>
              </div>
            </li>

            <li class="item-content item-input">
              <div class="item-inner">
                <div class="item-title item-label">Empiler les colonnes (stacked)</div>
                <div class="item-input-wrap">
                  <label class="toggle toggle-init">
                    <input type="checkbox" id="stackedColumns">
                    <span class="toggle-icon"></span>
                  </label>
                </div>
              </div>
            </li>

            <li class="item-content item-input">
              <div class="item-inner">
                <div class="item-title item-label">Charger un JSON (time series)</div>
                <div class="item-input-wrap">
                  <input type="file" id="jsonFile" accept="application/json,.json" />
                </div>
              </div>
            </li>

            <li class="item-content item-input">
              <div class="item-inner">
                <div class="item-title item-label">
                  JSON (éditable) — format attendu: <code>[[ts,value], ...]</code>
                </div>
                <div class="item-input-wrap">
                  <textarea id="jsonEditor" spellcheck="false">[[1719964800000,1],[1719968400000,3],[1719972000000,2],[1719975600000,4],[1719979200000,6]]</textarea>
                  <div class="muted">ts = timestamp (ms). Ex: [[1723257600000, 42], [1723261200000, 37]] — les clés <code>meta</code> / <code>_meta</code> sont ignorées.</div>
                </div>
              </div>
            </li>

            <li class="item-content item-input">
              <div class="item-inner">
                <div class="item-title item-label">Nom de la série / sauvegarde</div>
                <div class="item-input-wrap">
                  <input id="datasetName" type="text" placeholder="Nom pour sauvegarder" />
                </div>
              </div>
            </li>

            <li class="item-content item-input">
              <div class="item-inner">
                <div class="item-title item-label">Séries enregistrées (localStorage)</div>
                <div class="item-input-wrap">
                  <select id="savedList"></select>
                </div>
              </div>
            </li>
          </ul>
        </div>

        <div class="block button-row">
          <a href="#" class="button button-fill" id="applyBtn">Appliquer</a>
          <a href="#" class="button" id="saveBtn">Sauvegarder</a>
          <a href="#" class="button" id="loadBtn">Charger</a>
          <a href="#" class="button color-red" id="deleteBtn">Supprimer</a>
        </div>

        <div class="block">
          <p class="muted">
            Toute modification du JSON est <b>automatiquement sauvegardée</b> dans <code>localStorage</code> (jeu “courant”).  
            Les sauvegardes nommées apparaissent dans la liste et peuvent être rechargées.
          </p>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
  // ======= LocalStorage =======
  const LS_CURRENT_KEY = 'grapher.current.timeseries';
  const LS_SAVED_MAP_KEY = 'grapher.saved.timeseries.map'; // { name: jsonString }
  const lsGetSavedMap = () => { try { return JSON.parse(localStorage.getItem(LS_SAVED_MAP_KEY) || '{}'); } catch { return {}; } };
  const lsSetSavedMap = (m) => localStorage.setItem(LS_SAVED_MAP_KEY, JSON.stringify(m || {}));
  const lsGetCurrent = () => localStorage.getItem(LS_CURRENT_KEY) || '';
  const lsSetCurrent = (s) => localStorage.setItem(LS_CURRENT_KEY, String(s ?? ''));

  // ======= Parsing / Validation =======
  function stripMeta(obj) {
    if (!obj || typeof obj !== 'object') return obj;
    const clone = Array.isArray(obj) ? [...obj] : { ...obj };
    delete clone.meta;
    delete clone._meta;
    return clone;
  }
  function extractData(root) {
    // Supporte: tableau direct, {data:[...]}, {series:[...]}; ignore meta/_meta
    let r = stripMeta(root);
    if (r && !Array.isArray(r) && typeof r === 'object') {
      if (Array.isArray(r.data)) r = r.data;
      else if (Array.isArray(r.series)) r = r.series;
      else {
        // Si l'objet ne contient que meta/_meta → pas de data
        const keys = Object.keys(r);
        const filtered = keys.filter(k => k !== 'meta' && k !== '_meta');
        if (filtered.length === 0) r = [];
      }
    }
    return r;
  }
  function parseSeriesJson(str) {
    let parsed = JSON.parse(str);
    parsed = extractData(parsed);

    if (!Array.isArray(parsed)) throw new Error('Le JSON doit être un tableau de points ou un objet avec "data"/"series".');

    const norm = parsed.map(p => {
      if (!Array.isArray(p) || p.length < 2) throw new Error('Chaque point doit être [ts, value]');
      let ts = p[0], v = p[1];

      if (typeof ts === 'string') {
        const d = new Date(ts);
        if (isNaN(d)) throw new Error('Timestamp invalide: ' + ts);
        ts = d.getTime();
      }
      if (typeof ts === 'number' && ts < 1e12) ts = ts * 1000; // secondes -> ms (heuristique)

      const numV = Number(v);
      if (Number.isNaN(numV)) throw new Error('Valeur non numérique: ' + v);
      return [ts, numV];
    });

    norm.sort((a,b) => a[0] - b[0]);
    return norm;
  }
  const prettyJson = (arr) => JSON.stringify(arr, null, 2);

  // ======= Layout utils =======
  function isNavbarVisible() {
    const nav = document.querySelector('.navbar');
    if (!nav) return { visible: false, height: 0 };
    const style = getComputedStyle(nav);
    if (style.display === 'none' || style.visibility === 'hidden') return { visible: false, height: 0 };
    return { visible: true, height: nav.offsetHeight || 0 };
  }
  function viewportHeight() {
    // VisualViewport est plus fiable sur mobile
    return (window.visualViewport && window.visualViewport.height) || window.innerHeight;
  }
  function applyChartHeight() {
    const vh = viewportHeight();
    const { visible, height } = isNavbarVisible();
    const navH = visible ? height : 0;
    const h = Math.max(0, vh - navH);
    const el = document.getElementById('chart-container');
    el.style.height = h + 'px';
    el.style.maxHeight = h + 'px';
  }

  // ======= Highcharts Stock + F7 =======
  const app = new Framework7({
    el: '#app',
    on: {
      init: function () {
        // Sheet
        const sheet = this.sheet.create({
          el: '#controls-sheet',
          swipeToStep: true,
          swipeToClose: false,
          push: true,
          backdrop: true
        });
        // Limitation stricte de hauteur + scroll du contenu
        function limitSheetSize() {
          const vh = viewportHeight();
          const sheetEl = document.getElementById('controls-sheet');
          const inner = sheetEl.querySelector('.sheet-modal-inner');
          sheetEl.style.maxHeight = vh + 'px';
          inner.style.maxHeight = (vh - 20) + 'px'; // 20px ≈ handle
          inner.style.overflow = 'auto';
        }
        limitSheetSize();

        // Ouvrir par défaut en compact
        sheet.open(false);
        sheet.stepClose(false);

        document.getElementById('openControls').addEventListener('click', (e) => {
          e.preventDefault(); sheet.open();
        });

        // Tap-to-toggle
        document.getElementById('controls-sheet').addEventListener('click', (e) => {
          if (e.target.closest('a,button,select,input,textarea,label')) return;
          sheet.stepOpened ? sheet.stepClose() : sheet.stepOpen();
        });

        // Chart
        applyChartHeight();
        const chartEl = document.getElementById('chart-container');

        function isColumnLike(type){ return String(type).toLowerCase() === 'column'; }
        function yAxisIndexFor(type){ return isColumnLike(type) ? 0 : 1; }

        const $jsonEditor = document.getElementById('jsonEditor');
        const currentSaved = lsGetCurrent();
        if (currentSaved) $jsonEditor.value = currentSaved;

        const initialType = document.getElementById('seriesType').value || 'spline';
        const initialData = safeParseEditor(); // throws si invalide

        let chart = Highcharts.stockChart(chartEl, {
          chart: { animation: false },
          credits: { enabled: false },
          legend: { enabled: false },
          rangeSelector: { selected: 1 },
          tooltip: { shared: true, split: false },
          yAxis: [{
            title: { text: null }, opposite: false // gauche pour column/stacked
          },{
            title: { text: null }, opposite: true  // droite pour le reste
          }],
          plotOptions: {
            series: {
              dataGrouping: { enabled: true }
            }
          },
          series: [{
            name: 'S1',
            type: initialType,
            data: initialData,
            yAxis: yAxisIndexFor(initialType)
          }]
        });

        function reflow(){ try{ chart && chart.reflow(); }catch(e){} }
        function relayout(){ applyChartHeight(); reflow(); }
        sheet.on('stepOpen', ()=>{ limitSheetSize(); relayout(); });
        sheet.on('stepClose', ()=>{ limitSheetSize(); relayout(); });
        window.addEventListener('resize', ()=>{ limitSheetSize(); relayout(); }, { passive:true });
        window.addEventListener('orientationchange', ()=>{ setTimeout(()=>{ limitSheetSize(); relayout(); }, 200); });

        // ======= Contrôles =======
        const $type    = document.getElementById('seriesType');
        const $stacked = document.getElementById('stackedColumns');
        const $file    = document.getElementById('jsonFile');
        const $name    = document.getElementById('datasetName');
        const $list    = document.getElementById('savedList');

        function refreshSavedList(selectedName) {
          const map = lsGetSavedMap();
          $list.innerHTML = '';
          const optEmpty = document.createElement('option');
          optEmpty.value = ''; optEmpty.textContent = '-- sélectionner --';
          $list.appendChild(optEmpty);
          Object.keys(map).sort().forEach(name => {
            const opt = document.createElement('option');
            opt.value = name; opt.textContent = name;
            if (selectedName && name === selectedName) opt.selected = true;
            $list.appendChild(opt);
          });
        }
        refreshSavedList();

        function applyChanges() {
          const type = $type.value;
          const stacked = $stacked.checked;
          const data = safeParseEditor(); // valide et autosauve

          const stacking = (isColumnLike(type) && stacked) ? 'normal' : undefined;

          chart.update({
            plotOptions: { series: { stacking } },
            tooltip: { shared: true, split: false },
          }, false, true);

          chart.series[0].update({
            type,
            yAxis: yAxisIndexFor(type),
          }, false);

          chart.series[0].setData(data, false);
          chart.redraw();
          reflow();
        }

        // JSON editor: parse + autosave
        function safeParseEditor() {
          const raw = $jsonEditor.value.trim();
          lsSetCurrent(raw); // autosave du “courant”
          if (!raw) return [];
          const parsed = parseSeriesJson(raw);
          return parsed;
        }

        document.getElementById('applyBtn').addEventListener('click', (e) => {
          e.preventDefault();
          try { applyChanges(); }
          catch(err){ app.dialog.alert('JSON invalide : ' + err.message); }
        });

        document.getElementById('saveBtn').addEventListener('click', (e) => {
          e.preventDefault();
          const name = ($name.value || '').trim();
          if (!name) { app.dialog.alert('Donne un nom pour sauvegarder.'); return; }
          const raw = document.getElementById('jsonEditor').value.trim();
          if (!raw) { app.dialog.alert('Le JSON est vide.'); return; }
          try { parseSeriesJson(raw); } catch(err){ app.dialog.alert('JSON invalide : ' + err.message); return; }
          const map = lsGetSavedMap();
          map[name] = raw;
          lsSetSavedMap(map);
          refreshSavedList(name);
          app.toast.create({ text: 'Sauvegardé', closeTimeout: 1500 }).open();
        });

        document.getElementById('loadBtn').addEventListener('click', (e) => {
          e.preventDefault();
          const name = $list.value;
          if (!name) { app.dialog.alert('Sélectionne une sauvegarde.'); return; }
          const map = lsGetSavedMap();
          const raw = map[name];
          if (!raw) { app.dialog.alert('Introuvable en localStorage.'); return; }
          document.getElementById('jsonEditor').value = raw;
          lsSetCurrent(raw);
          try { applyChanges(); } catch(err){ app.dialog.alert('JSON invalide : ' + err.message); }
        });

        document.getElementById('deleteBtn').addEventListener('click', (e) => {
          e.preventDefault();
          const name = $list.value;
          if (!name) { app.dialog.alert('Sélectionne une sauvegarde à supprimer.'); return; }
          const map = lsGetSavedMap();
          delete map[name];
          lsSetSavedMap(map);
          refreshSavedList();
          app.toast.create({ text: 'Supprimé', closeTimeout: 1500 }).open();
        });

        // Upload JSON -> modifiable AVANT sauvegarde
        $file.addEventListener('change', async (e) => {
          const file = e.target.files?.[0];
          if (!file) return;
          try {
            const text = await file.text();
            // On injecte le texte dans l'éditeur (modifiable), sans forcer la sauvegarde nommée
            // Valider pour feedback rapide, mais on laisse modifiable avant "Sauvegarder"
            parseSeriesJson(text); // juste pour vérifier
            document.getElementById('jsonEditor').value = text;
            lsSetCurrent(text); // courant auto-sauvé
            app.toast.create({ text: 'Fichier chargé (modifiable avant sauvegarde)', closeTimeout: 2000 }).open();
          } catch(err){
            app.dialog.alert('JSON invalide : ' + err.message);
          } finally {
            e.target.value = '';
          }
        });

        // Autosave courant pendant la saisie
        let t; document.getElementById('jsonEditor').addEventListener('input', () => {
          clearTimeout(t);
          t = setTimeout(() => lsSetCurrent(document.getElementById('jsonEditor').value), 300);
        });

        // Changement de type / stacked => appliquer
        document.getElementById('seriesType').addEventListener('change', () => {
          try { applyChanges(); } catch(e){}
        });
        document.getElementById('stackedColumns').addEventListener('change', () => {
          try { applyChanges(); } catch(e){}
        });
      }
    }
  });
</script>
</body>
</html>
