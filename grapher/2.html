<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Grapher — Stock + per-series types + 75% sheet</title>

  <!-- Framework7 + Highcharts Stock -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/framework7@8.3.4/framework7-bundle.min.css" />
  <script src="https://cdn.jsdelivr.net/npm/framework7@8.3.4/framework7-bundle.min.js"></script>
  <script src="https://code.highcharts.com/stock/highstock.js"></script>

  <style>
    :root { --nav-h: var(--f7-navbar-height, 44px); }

    /* Chart: 100% width, height fits viewport minus navbar, never exceeds screen */
    #chart-container {
      width: 100%;
      height: calc(100vh - var(--nav-h));
      max-height: calc(100vh - var(--nav-h));
    }

    /* Sheet: two steps + push, expanded <= 75% of screen, content scrollable */
    #controls-sheet { height: auto; max-height: 75vh; }
    #controls-sheet .sheet-modal-swipe-step { min-height: 92px; }
    .sheet-handle { height: 20px; display:flex; align-items:center; justify-content:center; }
    .sheet-handle::before { content:""; width:36px; height:4px; border-radius:2px; background:#999; opacity:.6; }

    /* When expanded, inner is scrollable and still capped at 75% */
    #controls-sheet .sheet-modal-inner {
      max-height: calc(75vh - 20px); /* 20px ≈ handle */
      overflow: auto;
    }

    /* Controls styling */
    .ctrls .list input, .ctrls .list select, .ctrls .list textarea { width: 100%; }
    .ctrls .button-row { display: flex; gap: 8px; flex-wrap: wrap; }
    .ctrls .button-row .button { flex: 1; min-width: 120px; }
    .ctrls textarea { min-height: 160px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; font-size: 12px; }
    .muted { color: var(--f7-text-muted); font-size: 12px; }

    /* Series table with per-series Type column */
    #seriesSettings { width: 100%; border-collapse: collapse; font-size: 13px; }
    #seriesSettings th, #seriesSettings td { padding: 6px 8px; border-bottom: 1px solid #eee; vertical-align: middle; }
    #seriesSettings th { text-align: left; }
    #seriesSettings select { width: 100%; }

    /* Hide navbar in landscape; chart height auto-adjusts via JS */
    @media (orientation: landscape) {
      .navbar { display: none !important; }
      :root { --nav-h: 0px; }
    }
  </style>
</head>
<body>
<div id="app">
  <div class="view view-main view-init" data-url="/">
    <div class="page">
      <div class="navbar">
        <div class="navbar-bg"></div>
        <div class="navbar-inner">
          <div class="title">Grapher (Stock)</div>
          <div class="right"><a href="#" class="link" id="openControls">Contrôles</a></div>
        </div>
      </div>

      <div class="page-content">
        <div id="chart-container"></div>
      </div>
    </div>
  </div>

  <!-- SHEET = CONTROLS (max 75% viewport, scrollable) -->
  <div class="sheet-modal sheet-modal-push" id="controls-sheet">
    <div class="sheet-handle"></div>
    <div class="sheet-modal-inner">
      <div class="sheet-modal-swipe-step">
        <div class="block no-margin">
          <p class="no-margin text-color-gray">Contrôles — swipe/tap pour agrandir (≤ 75% écran) ⤴︎</p>
        </div>
      </div>

      <div class="block crtls">
        <div class="list inset">
          <ul>
            <li class="item-content item-input">
              <div class="item-inner">
                <div class="item-title item-label">Default type (new series)</div>
                <div class="item-input-wrap">
                  <select id="defaultSeriesType">
                    <option value="spline" selected>Spline</option>
                    <option value="line">Line</option>
                    <option value="area">Area</option>
                    <option value="areaspline">Area Spline</option>
                    <option value="column">Column</option>
                    <option value="scatter">Scatter</option>
                  </select>
                </div>
              </div>
            </li>

            <li class="item-content item-input">
              <div class="item-inner">
                <div class="item-title item-label">Stack columns</div>
                <div class="item-input-wrap">
                  <label class="toggle toggle-init">
                    <input type="checkbox" id="stackedColumns" />
                    <span class="toggle-icon"></span>
                  </label>
                </div>
              </div>
            </li>

            <li class="item-content item-input">
              <div class="item-inner">
                <div class="item-title item-label">Upload JSON (time series)</div>
                <div class="item-input-wrap">
                  <input type="file" id="jsonFile" accept="application/json,.json" />
                </div>
              </div>
            </li>

            <li class="item-content item-input">
              <div class="item-inner">
                <div class="item-title item-label">
                  JSON (editable) — accepted: <code>[[ts,val],...]</code> • <code>{data:[...]}</code> • <code>{ series:[{name,data,meta?}], ... }</code> • <code>{ "http-2xx":[...],"_meta":{...} }</code>
                </div>
                <div class="item-input-wrap">
                  <textarea id="jsonEditor" spellcheck="false">[[1719964800000,1],[1719968400000,3],[1719972000000,2]]</textarea>
                  <div class="muted">
                    Keys <code>meta</code> / <code>_meta</code> ignored (global & per-series).  
                    Multiple keys create multiple series.
                  </div>
                </div>
              </div>
            </li>
          </ul>
        </div>

        <!-- Per-series settings (includes Type column as requested) -->
        <div class="block">
          <div class="block-title">Detected series</div>
          <div class="block">
            <table id="seriesSettings">
              <thead>
                <tr>
                  <th>Name</th>
                  <th>Type</th>         <!-- <= you can change per-series types here -->
                  <th>Aggregation</th>
                </tr>
              </thead>
              <tbody id="seriesSettingsBody"></tbody>
            </table>
          </div>
        </div>

        <div class="block">
          <div class="list inset">
            <ul>
              <li class="item-content item-input">
                <div class="item-inner">
                  <div class="item-title item-label">Save name</div>
                  <div class="item-input-wrap">
                    <input id="datasetName" type="text" placeholder="Preset name" />
                  </div>
                </div>
              </li>
              <li class="item-content item-input">
                <div class="item-inner">
                  <div class="item-title item-label">Saved presets (localStorage)</div>
                  <div class="item-input-wrap">
                    <select id="savedList"></select>
                  </div>
                </div>
              </li>
            </ul>
          </div>

          <div class="block button-row">
            <a href="#" class="button button-fill" id="applyBtn">Apply</a>
            <a href="#" class="button" id="saveBtn">Save</a>
            <a href="#" class="button" id="loadBtn">Load</a>
            <a href="#" class="button color-red" id="deleteBtn">Delete</a>
          </div>
        </div>

        <div class="block">
          <p class="muted">
            Current JSON & per-series settings are auto-saved.  
            Named presets store <b>JSON + settings</b>.
          </p>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
  /* ===== LocalStorage ===== */
  const LS_CURRENT_KEY = 'grapher.current.timeseries';
  const LS_CURRENT_SETTINGS_KEY = 'grapher.current.series.settings'; // map name -> {type, agg}
  const LS_SAVED_MAP_KEY = 'grapher.saved.timeseries.map';           // map presetName -> { json, settings }

  const lsGetSavedMap = () => { try { return JSON.parse(localStorage.getItem(LS_SAVED_MAP_KEY) || '{}'); } catch { return {}; } };
  const lsSetSavedMap = (m) => localStorage.setItem(LS_SAVED_MAP_KEY, JSON.stringify(m || {}));

  const lsGetCurrentJson = () => localStorage.getItem(LS_CURRENT_KEY) || '';
  const lsSetCurrentJson = (s) => localStorage.setItem(LS_CURRENT_KEY, String(s ?? ''));

  const lsGetCurrentSettings = () => { try { return JSON.parse(localStorage.getItem(LS_CURRENT_SETTINGS_KEY) || '{}'); } catch { return {}; } };
  const lsSetCurrentSettings = (m) => localStorage.setItem(LS_CURRENT_SETTINGS_KEY, JSON.stringify(m || {}));

  /* ===== Parsing / Normalisation ===== */
  const IGNORED_KEYS = new Set(['meta','_meta']);
  const TYPE_OPTIONS = ['spline','line','area','areaspline','column','scatter'];
  const AGG_OPTIONS  = ['auto','sum','average'];

  function normalizePoints(arr) {
    return arr.map(p => {
      if (!Array.isArray(p) || p.length < 2) throw new Error('Each point must be [ts, value]');
      let ts = p[0], v = p[1];
      if (typeof ts === 'string') { const d = new Date(ts); if (isNaN(d)) throw new Error('Invalid ts: '+ts); ts = d.getTime(); }
      if (typeof ts === 'number' && ts < 1e12) ts = ts * 1000; // seconds -> ms (heuristic)
      const numV = Number(v); if (Number.isNaN(numV)) throw new Error('Non numeric value: '+v);
      return [ts, numV];
    }).sort((a,b)=>a[0]-b[0]);
  }

  function detectAggByName(name='') {
    const n = String(name).toLowerCase();
    const isCount = /(^|[^a-z])(count|hits?|reqs?|requests?|events?)([^a-z]|$)/i.test(n)
                 || /(^|[^a-z])(1xx|2xx|3xx|4xx|5xx)([^a-z]|$)/i.test(n);
    const isAvg   = /(avg|average|mean|latency|response|time|rt|duration|ms|s|p\d{2})/i.test(n);
    if (isAvg && !isCount) return 'average';
    if (isCount && !isAvg) return 'sum';
    return 'auto';
  }
  function detectAggFromMeta(meta) {
    if (!meta || typeof meta !== 'object') return null;
    const agg = (meta.agg || meta.approximation || meta.approx || '').toLowerCase();
    const metric = (meta.metric || '').toLowerCase();
    if (agg === 'sum' || metric === 'count') return 'sum';
    if (agg === 'average' || agg === 'avg' || metric === 'average') return 'average';
    return null;
  }

  // Returns { series:[{name,data,meta?}], rootMeta? }
  function parseAnySeries(str) {
    let root = JSON.parse(str);
    let rootMeta = (root && (root._meta || root.meta)) || null;

    if (Array.isArray(root)) {
      return { series: [{ name: 'S1', data: normalizePoints(root) }], rootMeta: null };
    }
    if (root && typeof root === 'object') {
      if (Array.isArray(root.data)) {
        return { series: [{ name: 'S1', data: normalizePoints(root.data), meta: (root.data_meta||null) }], rootMeta };
      }
      if (Array.isArray(root.series)) {
        const s = root.series;
        if (Array.isArray(s[0])) return { series: [{ name:'S1', data: normalizePoints(s) }], rootMeta };
        const out = s.map((it, idx) => ({
          name: it?.name || ('S'+(idx+1)),
          data: Array.isArray(it?.data) ? normalizePoints(it.data) : [],
          meta: it?.meta || it?._meta || null
        })).filter(s=>s.data.length);
        if (out.length) return { series: out, rootMeta };
      }
      const keys = Object.keys(root).filter(k => !IGNORED_KEYS.has(k));
      const out = [];
      keys.forEach(k => {
        const v = root[k];
        if (Array.isArray(v)) out.push({ name: k, data: normalizePoints(v) });
        else if (v && typeof v === 'object' && Array.isArray(v.data)) {
          out.push({ name: k, data: normalizePoints(v.data), meta: (v.meta||v._meta||null) });
        }
      });
      if (out.length) return { series: out, rootMeta };
    }
    throw new Error('Unsupported format.');
  }

  /* ===== Layout helpers ===== */
  function viewportHeight() {
    return (window.visualViewport && window.visualViewport.height) || window.innerHeight;
  }
  function isNavbarVisible() {
    const nav = document.querySelector('.navbar');
    if (!nav) return { visible:false, height:0 };
    const st = getComputedStyle(nav);
    if (st.display === 'none' || st.visibility === 'hidden') return { visible:false, height:0 };
    return { visible:true, height: nav.offsetHeight||0 };
  }
  function applyChartHeight() {
    const vh = viewportHeight();
    const { visible, height } = isNavbarVisible();
    const navH = visible ? height : 0;
    const h = Math.max(0, vh - navH);
    const el = document.getElementById('chart-container');
    el.style.height = h + 'px';
    el.style.maxHeight = h + 'px';
  }

  function isColumnLike(t){ return String(t).toLowerCase() === 'column'; }
  function yAxisIndexFor(t){ return isColumnLike(t) ? 0 : 1; }

  /* ===== App ===== */
  const app = new Framework7({
    el: '#app',
    on: {
      init: function () {
        // Sheet (limit open height to 75% of viewport)
        const sheet = this.sheet.create({
          el: '#controls-sheet',
          swipeToStep: true,
          swipeToClose: false,
          push: true,
          backdrop: true
        });
        const sheetEl = document.getElementById('controls-sheet');
        const innerEl = sheetEl.querySelector('.sheet-modal-inner');

        function capSheetTo75vh(){
          const vh = viewportHeight();
          const max = Math.floor(vh * 0.75);
          sheetEl.style.maxHeight = max + 'px';
          innerEl.style.maxHeight = (max - 20) + 'px'; // keep it scrollable
          innerEl.style.overflow = 'auto';
        }
        capSheetTo75vh();

        // Open compact by default; tap background of sheet toggles step
        sheet.open(false); sheet.stepClose(false);
        document.getElementById('openControls').addEventListener('click', (e) => { e.preventDefault(); sheet.open(); });
        sheetEl.addEventListener('click', (e) => {
          if (e.target.closest('a,button,select,input,textarea,label')) return;
          sheet.stepOpened ? sheet.stepClose() : sheet.stepOpen();
        });

        // Chart init
        applyChartHeight();
        const chartEl = document.getElementById('chart-container');

        // Current JSON & settings
        const $jsonEditor = document.getElementById('jsonEditor');
        const currentJson = lsGetCurrentJson();
        if (currentJson) $jsonEditor.value = currentJson;
        let seriesSettings = lsGetCurrentSettings(); // { name: {type, agg} }

        // Parse & merge settings
        let parsed = parseAnySeries($jsonEditor.value.trim());
        seriesSettings = initOrMergeSeriesSettings(parsed, seriesSettings);

        // Render per-series settings table (includes Type column)
        renderSeriesSettingsTable(parsed, seriesSettings);

        let chart = Highcharts.stockChart(chartEl, buildChartOptions(parsed, seriesSettings));

        function reflow(){ try{ chart && chart.reflow(); }catch(e){} }
        function relayout(){ applyChartHeight(); capSheetTo75vh(); reflow(); }

        sheet.on('stepOpen', relayout);
        sheet.on('stepClose', relayout);
        window.addEventListener('resize', relayout, { passive:true });
        window.addEventListener('orientationchange', ()=> setTimeout(relayout, 200), { passive:true });

        /* ===== Controls ===== */
        const $defaultType = document.getElementById('defaultSeriesType');
        const $stacked     = document.getElementById('stackedColumns');
        const $file        = document.getElementById('jsonFile');
        const $name        = document.getElementById('datasetName');
        const $list        = document.getElementById('savedList');

        refreshSavedList();

        document.getElementById('applyBtn').addEventListener('click', (e)=>{
          e.preventDefault();
          try {
            parsed = parseAnySeries($jsonEditor.value.trim());
            seriesSettings = collectSeriesSettingsFromUI(parsed, seriesSettings, $defaultType.value);
            lsSetCurrentJson($jsonEditor.value.trim());
            lsSetCurrentSettings(seriesSettings);

            // Rebuild chart with possibly changed series/types/agg
            while (chart.series.length) chart.series[0].remove(false);
            const opts = buildChartOptions(parsed, seriesSettings, $stacked.checked);
            chart.update({ plotOptions: opts.plotOptions, yAxis: opts.yAxis, tooltip: opts.tooltip }, false, true);
            opts.series.forEach(s => chart.addSeries(s, false));
            chart.redraw();
            relayout();
          } catch(err) {
            app.dialog.alert('Invalid JSON: ' + err.message);
          }
        });

        document.getElementById('saveBtn').addEventListener('click', (e)=>{
          e.preventDefault();
          const nm = ($name.value||'').trim();
          if (!nm) return app.dialog.alert('Name required.');
          try { parseAnySeries($jsonEditor.value.trim()); } catch(err){ return app.dialog.alert('Invalid JSON: ' + err.message); }
          const map = lsGetSavedMap();
          map[nm] = { json: $jsonEditor.value.trim(), settings: collectSeriesSettingsFromUI(parsed, seriesSettings, $defaultType.value) };
          lsSetSavedMap(map);
          refreshSavedList(nm);
          app.toast.create({ text: 'Saved', closeTimeout: 1500 }).open();
        });

        document.getElementById('loadBtn').addEventListener('click', (e)=>{
          e.preventDefault();
          const nm = $list.value;
          if (!nm) return app.dialog.alert('Select a preset.');
          const rec = lsGetSavedMap()[nm];
          if (!rec || !rec.json) return app.dialog.alert('Preset not found.');
          try { parsed = parseAnySeries(rec.json); } catch(err){ return app.dialog.alert('Preset JSON invalid: '+err.message); }

          $jsonEditor.value = rec.json;
          lsSetCurrentJson(rec.json);
          seriesSettings = initOrMergeSeriesSettings(parsed, rec.settings || {});
          lsSetCurrentSettings(seriesSettings);
          renderSeriesSettingsTable(parsed, seriesSettings);

          // Rebuild chart
          while (chart.series.length) chart.series[0].remove(false);
          const opts = buildChartOptions(parsed, seriesSettings, $stacked.checked);
          chart.update({ plotOptions: opts.plotOptions, yAxis: opts.yAxis, tooltip: opts.tooltip }, false, true);
          opts.series.forEach(s => chart.addSeries(s, false));
          chart.redraw();
          relayout();
        });

        document.getElementById('deleteBtn').addEventListener('click', (e)=>{
          e.preventDefault();
          const nm = $list.value;
          if (!nm) return app.dialog.alert('Select a preset to delete.');
          const map = lsGetSavedMap(); delete map[nm]; lsSetSavedMap(map);
          refreshSavedList();
          app.toast.create({ text: 'Deleted', closeTimeout: 1500 }).open();
        });

        $file.addEventListener('change', async (e)=>{
          const f = e.target.files?.[0]; if (!f) return;
          try {
            const text = await f.text();
            const tmp = parseAnySeries(text); // validate
            $jsonEditor.value = text;
            lsSetCurrentJson(text);
            seriesSettings = initOrMergeSeriesSettings(tmp, seriesSettings, $defaultType.value);
            lsSetCurrentSettings(seriesSettings);
            renderSeriesSettingsTable(tmp, seriesSettings);
            app.toast.create({ text: 'File loaded (editable before save)', closeTimeout: 2000 }).open();
          } catch(err){
            app.dialog.alert('Invalid JSON: ' + err.message);
          } finally { e.target.value=''; }
        });

        // Auto-save current JSON while typing
        let t; document.getElementById('jsonEditor').addEventListener('input', ()=>{
          clearTimeout(t);
          t = setTimeout(()=> lsSetCurrentJson(document.getElementById('jsonEditor').value), 300);
        });

        // Stacked toggle -> rebuild using existing parsed/settings
        document.getElementById('stackedColumns').addEventListener('change', ()=>{
          try {
            seriesSettings = collectSeriesSettingsFromUI(parsed, seriesSettings, $defaultType.value);
            lsSetCurrentSettings(seriesSettings);
            while (chart.series.length) chart.series[0].remove(false);
            const opts = buildChartOptions(parsed, seriesSettings, $stacked.checked);
            chart.update({ plotOptions: opts.plotOptions, yAxis: opts.yAxis, tooltip: opts.tooltip }, false, true);
            opts.series.forEach(s => chart.addSeries(s, false));
            chart.redraw();
            relayout();
          } catch(e){}
        });

        /* ===== Helpers ===== */
        function refreshSavedList(selected) {
          const map = lsGetSavedMap();
          const sel = document.getElementById('savedList');
          sel.innerHTML = '';
          const opt = document.createElement('option');
          opt.value = ''; opt.textContent = '-- select --';
          sel.appendChild(opt);
          Object.keys(map).sort().forEach(n=>{
            const o=document.createElement('option'); o.value=n; o.textContent=n;
            if (selected && n===selected) o.selected = true;
            sel.appendChild(o);
          });
        }

        function initOrMergeSeriesSettings(parsed, existing={}, defaultType='spline') {
          const out = { ...existing };
          parsed.series.forEach(s => {
            if (!out[s.name]) {
              const aggFromMeta = detectAggFromMeta(s.meta) ?? detectAggFromMeta(parsed.rootMeta);
              const autoAgg = aggFromMeta || detectAggByName(s.name) || 'auto';
              out[s.name] = {
                type: TYPE_OPTIONS.includes(defaultType) ? defaultType : 'spline',
                agg: AGG_OPTIONS.includes(autoAgg) ? autoAgg : 'auto'
              };
            }
          });
          // prune orphans
          Object.keys(out).forEach(k=>{
            if (!parsed.series.find(s=>s.name===k)) delete out[k];
          });
          return out;
        }

        function renderSeriesSettingsTable(parsed, settings) {
          const tbody = document.getElementById('seriesSettingsBody');
          tbody.innerHTML = '';
          parsed.series.forEach(s => {
            const row = document.createElement('tr');

            const cName = document.createElement('td');
            cName.textContent = s.name;

            const cType = document.createElement('td');
            const selType = document.createElement('select');
            TYPE_OPTIONS.forEach(t => {
              const opt = document.createElement('option');
              opt.value=t; opt.textContent=t;
              if ((settings[s.name]?.type||'spline') === t) opt.selected = true;
              selType.appendChild(opt);
            });
            selType.addEventListener('change', ()=>{
              settings[s.name] = settings[s.name] || {};
              settings[s.name].type = selType.value;
              lsSetCurrentSettings(settings);
            });
            cType.appendChild(selType);

            const cAgg = document.createElement('td');
            const selAgg = document.createElement('select');
            AGG_OPTIONS.forEach(a => {
              const opt = document.createElement('option');
              opt.value=a; opt.textContent=a;
              if ((settings[s.name]?.agg||'auto') === a) opt.selected = true;
              selAgg.appendChild(opt);
            });
            selAgg.addEventListener('change', ()=>{
              settings[s.name] = settings[s.name] || {};
              settings[s.name].agg = selAgg.value;
              lsSetCurrentSettings(settings);
            });
            cAgg.appendChild(selAgg);

            row.appendChild(cName); row.appendChild(cType); row.appendChild(cAgg);
            tbody.appendChild(row);
          });
        }

        function aggToApprox(agg, fallbackName) {
          if (agg === 'sum' || agg === 'average') return agg;
          const auto = detectAggByName(fallbackName);
          return (auto === 'sum' || auto === 'average') ? auto : 'sum';
        }

        function buildChartOptions(parsed, settings, stacked=false) {
          const series = parsed.series.map(s => {
            const cfg = settings[s.name] || {};
            const t = TYPE_OPTIONS.includes(cfg.type) ? cfg.type : 'spline';
            const approx = aggToApprox(cfg.agg || 'auto', s.name);
            const y = yAxisIndexFor(t);
            return {
              name: s.name,
              type: t,
              data: s.data,
              yAxis: y,
              dataGrouping: { enabled: true, approximation: approx }
            };
          });

          return {
            tooltip: { shared: true, split: false },
            yAxis: [{ title: { text: null }, opposite: false },
                    { title: { text: null }, opposite: true }],
            plotOptions: { series: { stacking: stacked ? 'normal' : undefined } },
            series
          };
        }
      }
    }
  });
</script>
</body>
</html>
