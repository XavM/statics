<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Grapher — Chart en page / Contrôles en sheet (Stock + multi-séries)</title>

  <!-- Framework7 + Highcharts Stock -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/framework7@8.3.4/framework7-bundle.min.css" />
  <script src="https://cdn.jsdelivr.net/npm/framework7@8.3.4/framework7-bundle.min.js"></script>
  <script src="https://code.highcharts.com/stock/highstock.js"></script>

  <style>
    :root { --nav-h: var(--f7-navbar-height, 44px); }

    /* Graph: 100% largeur, hauteur = viewport - navbar (navigator inclus), ne dépasse jamais l'écran */
    #chart-container {
      width: 100%;
      height: calc(100vh - var(--nav-h));
      max-height: calc(100vh - var(--nav-h));
    }

    /* Sheet: 2 steps + push, ne dépasse pas 100vh et scrollable */
    #controls-sheet { height: auto; max-height: 100vh; }
    #controls-sheet .sheet-modal-swipe-step { min-height: 92px; }
    .sheet-handle { height: 20px; display:flex; align-items:center; justify-content:center; }
    .sheet-handle::before { content:""; width:36px; height:4px; border-radius:2px; background:#999; opacity:.6; }
    #controls-sheet .sheet-modal-inner {
      max-height: calc(100vh - 20px);
      overflow: auto;
    }

    /* Contrôles */
    .ctrls .list input, .ctrls .list select, .ctrls .list textarea { width: 100%; }
    .ctrls .button-row { display: flex; gap: 8px; flex-wrap: wrap; }
    .ctrls .button-row .button { flex: 1; min-width: 120px; }
    .ctrls textarea {
      min-height: 160px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      font-size: 12px;
    }
    .muted { color: var(--f7-text-muted); font-size: 12px; }

    /* Navbar cachée en paysage */
    @media (orientation: landscape) {
      .navbar { display: none !important; }
      :root { --nav-h: 0px; }
    }
  </style>
</head>
<body>
<div id="app">
  <div class="view view-main view-init" data-url="/">
    <div class="page">
      <div class="navbar">
        <div class="navbar-bg"></div>
        <div class="navbar-inner">
          <div class="title">Grapher (Stock)</div>
          <div class="right"><a href="#" class="link" id="openControls">Contrôles</a></div>
        </div>
      </div>

      <div class="page-content">
        <div id="chart-container"></div>
      </div>
    </div>
  </div>

  <!-- SHEET = CONTRÔLES -->
  <div class="sheet-modal sheet-modal-push" id="controls-sheet">
    <div class="sheet-handle"></div>
    <div class="sheet-modal-inner">
      <div class="sheet-modal-swipe-step">
        <div class="block no-margin">
          <p class="no-margin text-color-gray">Contrôles — swipe/tap pour agrandir ⤴︎</p>
        </div>
      </div>

      <div class="block crtls">
        <div class="list inset">
          <ul>
            <li class="item-content item-input">
              <div class="item-inner">
                <div class="item-title item-label">Type des séries</div>
                <div class="item-input-wrap">
                  <select id="seriesType">
                    <option value="spline" selected>Spline</option>
                    <option value="line">Line</option>
                    <option value="area">Area</option>
                    <option value="areaspline">Area Spline</option>
                    <option value="column">Column</option>
                    <option value="scatter">Scatter</option>
                  </select>
                </div>
              </div>
            </li>

            <li class="item-content item-input">
              <div class="item-inner">
                <div class="item-title item-label">Empiler les colonnes (stacked)</div>
                <div class="item-input-wrap">
                  <label class="toggle toggle-init">
                    <input type="checkbox" id="stackedColumns">
                    <span class="toggle-icon"></span>
                  </label>
                </div>
              </div>
            </li>

            <li class="item-content item-input">
              <div class="item-inner">
                <div class="item-title item-label">Charger un JSON (time series)</div>
                <div class="item-input-wrap">
                  <input type="file" id="jsonFile" accept="application/json,.json" />
                </div>
              </div>
            </li>

            <li class="item-content item-input">
              <div class="item-inner">
                <div class="item-title item-label">
                  JSON (éditable) — formats acceptés:
                  <br><code>[[ts,val],...]</code> • <code>{data:[...]}</code> • <code>{ seriesName:[...], other:[...] }</code>
                </div>
                <div class="item-input-wrap">
                  <textarea id="jsonEditor" spellcheck="false">[[1719964800000,1],[1719968400000,3],[1719972000000,2]]</textarea>
                  <div class="muted">
                    - <b>Clés ignorées</b>: <code>meta</code>, <code>_meta</code>.<br>
                    - Si plusieurs clés (ex. <code>{"http-2xx":[...],"http-5xx":[...]}</code>), une <b>série par clé</b> est créée.
                  </div>
                </div>
              </div>
            </li>

            <li class="item-content item-input">
              <div class="item-inner">
                <div class="item-title item-label">Nom (pour sauvegarder)</div>
                <div class="item-input-wrap">
                  <input id="datasetName" type="text" placeholder="Nom de la sauvegarde" />
                </div>
              </div>
            </li>

            <li class="item-content item-input">
              <div class="item-inner">
                <div class="item-title item-label">Séries enregistrées (localStorage)</div>
                <div class="item-input-wrap">
                  <select id="savedList"></select>
                </div>
              </div>
            </li>
          </ul>
        </div>

        <div class="block button-row">
          <a href="#" class="button button-fill" id="applyBtn">Appliquer</a>
          <a href="#" class="button" id="saveBtn">Sauvegarder</a>
          <a href="#" class="button" id="loadBtn">Charger</a>
          <a href="#" class="button color-red" id="deleteBtn">Supprimer</a>
        </div>

        <div class="block">
          <p class="muted">
            Toute modification du JSON est <b>auto-sauvegardée</b> (jeu “courant”).  
            Les sauvegardes nommées sont listées ci-dessus.
          </p>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
  /* ===== LocalStorage ===== */
  const LS_CURRENT_KEY = 'grapher.current.timeseries';
  const LS_SAVED_MAP_KEY = 'grapher.saved.timeseries.map';
  const lsGetSavedMap = () => { try { return JSON.parse(localStorage.getItem(LS_SAVED_MAP_KEY) || '{}'); } catch { return {}; } };
  const lsSetSavedMap = (m) => localStorage.setItem(LS_SAVED_MAP_KEY, JSON.stringify(m || {}));
  const lsGetCurrent = () => localStorage.getItem(LS_CURRENT_KEY) || '';
  const lsSetCurrent = (s) => localStorage.setItem(LS_CURRENT_KEY, String(s ?? ''));

  /* ===== Parsing / Normalisation ===== */
  const IGNORED_KEYS = new Set(['meta','_meta']);

  function normalizePoints(arr) {
    return arr.map(p => {
      if (!Array.isArray(p) || p.length < 2) throw new Error('Chaque point doit être [ts, value]');
      let ts = p[0], v = p[1];

      if (typeof ts === 'string') {
        const d = new Date(ts);
        if (isNaN(d)) throw new Error('Timestamp invalide: ' + ts);
        ts = d.getTime();
      }
      if (typeof ts === 'number' && ts < 1e12) ts = ts * 1000; // secondes -> ms (heuristique)

      const numV = Number(v);
      if (Number.isNaN(numV)) throw new Error('Valeur non numérique: ' + v);
      return [ts, numV];
    }).sort((a,b)=>a[0]-b[0]);
  }

  // Retourne { series: [{name,data}, ...] }
  function parseAnySeries(str) {
    let root = JSON.parse(str);
    // cas tableau direct: [[ts,val],...]
    if (Array.isArray(root)) {
      return { series: [{ name: 'S1', data: normalizePoints(root) }] };
    }
    // cas objet: on ignore meta/_meta
    if (root && typeof root === 'object') {
      // { data:[...] }
      if (Array.isArray(root.data)) {
        return { series: [{ name: 'S1', data: normalizePoints(root.data) }] };
      }
      // { series:[...] } → si c'est un tableau de points, on le prend; si c'est un tableau de séries, on mappe
      if (Array.isArray(root.series)) {
        const s = root.series;
        // si series est un tableau de points
        if (Array.isArray(s[0])) return { series: [{ name:'S1', data: normalizePoints(s) }] };
        // sinon objet(s) {name, data}
        const out = s.map((it, idx) => {
          const name = it && (it.name || ('S'+(idx+1)));
          const data = Array.isArray(it?.data) ? normalizePoints(it.data) : [];
          return { name, data };
        }).filter(s=>s.data.length);
        if (out.length) return { series: out };
      }
      // mapping libre { key1:[...], key2:[...], _meta:{...} }
      const keys = Object.keys(root).filter(k => !IGNORED_KEYS.has(k));
      const out = [];
      keys.forEach((k, i) => {
        const val = root[k];
        if (Array.isArray(val)) out.push({ name: k, data: normalizePoints(val) });
        else if (val && typeof val === 'object' && Array.isArray(val.data)) {
          out.push({ name: k, data: normalizePoints(val.data) });
        }
      });
      if (out.length) return { series: out };
    }
    throw new Error('Format non reconnu. Utilise [[ts,val],...], {data:[...]}, {series:[...]}, ou {nom:[...],...}.');
  }

  /* ===== UI / Chart helpers ===== */
  function viewportHeight() {
    return (window.visualViewport && window.visualViewport.height) || window.innerHeight;
  }
  function isNavbarVisible() {
    const nav = document.querySelector('.navbar');
    if (!nav) return { visible:false, height:0 };
    const st = getComputedStyle(nav);
    if (st.display === 'none' || st.visibility === 'hidden') return { visible:false, height:0 };
    return { visible:true, height: nav.offsetHeight||0 };
  }
  function applyChartHeight() {
    const vh = viewportHeight();
    const { visible, height } = isNavbarVisible();
    const navH = visible ? height : 0;
    const h = Math.max(0, vh - navH);
    const el = document.getElementById('chart-container');
    el.style.height = h + 'px';
    el.style.maxHeight = h + 'px';
  }

  function isColumnLike(type){ return String(type).toLowerCase() === 'column'; }
  function yAxisIndexFor(type){ return isColumnLike(type) ? 0 : 1; }

  /* ===== App ===== */
  const app = new Framework7({
    el: '#app',
    on: {
      init: function () {
        // Sheet
        const sheet = this.sheet.create({
          el: '#controls-sheet',
          swipeToStep: true,
          swipeToClose: false,
          push: true,
          backdrop: true
        });
        const sheetEl = document.getElementById('controls-sheet');
        function limitSheetSize(){
          const vh = viewportHeight();
          sheetEl.style.maxHeight = vh + 'px';
          sheetEl.querySelector('.sheet-modal-inner').style.maxHeight = (vh - 20) + 'px';
        }
        limitSheetSize();
        sheet.open(false); sheet.stepClose(false);
        document.getElementById('openControls').addEventListener('click', (e) => { e.preventDefault(); sheet.open(); });
        sheetEl.addEventListener('click', (e) => {
          if (e.target.closest('a,button,select,input,textarea,label')) return;
          sheet.stepOpened ? sheet.stepClose() : sheet.stepOpen();
        });

        // Chart
        applyChartHeight();
        const chartEl = document.getElementById('chart-container');

        // Initial data (depuis localStorage si présent)
        const $jsonEditor = document.getElementById('jsonEditor');
        const currentSaved = lsGetCurrent();
        if (currentSaved) $jsonEditor.value = currentSaved;

        const initialParsed = parseAnySeries($jsonEditor.value.trim());
        const initialType = document.getElementById('seriesType').value || 'spline';

        let chart = Highcharts.stockChart(chartEl, {
          chart: { animation: false },
          credits: { enabled: false },
          legend: { enabled: true },
          rangeSelector: { selected: 1 },
          tooltip: { shared: true, split: false },
          yAxis: [{
            title: { text: null }, opposite: false
          },{
            title: { text: null }, opposite: true
          }],
          plotOptions: { series: { dataGrouping: { enabled: true } } },
          series: initialParsed.series.map(s => ({
            name: s.name,
            type: initialType,
            data: s.data,
            yAxis: yAxisIndexFor(initialType)
          }))
        });

        function reflow(){ try{ chart && chart.reflow(); }catch(e){} }
        function relayout(){ applyChartHeight(); reflow(); }
        sheet.on('stepOpen', relayout);
        sheet.on('stepClose', relayout);
        window.addEventListener('resize', ()=>{ limitSheetSize(); relayout(); }, { passive:true });
        window.addEventListener('orientationchange', ()=> setTimeout(()=>{ limitSheetSize(); relayout(); }, 200), { passive:true });

        /* ===== Contrôles ===== */
        const $type    = document.getElementById('seriesType');
        const $stacked = document.getElementById('stackedColumns');
        const $file    = document.getElementById('jsonFile');
        const $name    = document.getElementById('datasetName');
        const $list    = document.getElementById('savedList');

        function refreshSavedList(selectedName) {
          const map = lsGetSavedMap();
          $list.innerHTML = '';
          const opt = document.createElement('option');
          opt.value=''; opt.textContent='-- sélectionner --';
          $list.appendChild(opt);
          Object.keys(map).sort().forEach(n=>{
            const o=document.createElement('option'); o.value=n; o.textContent=n;
            if (selectedName && n === selectedName) o.selected = true;
            $list.appendChild(o);
          });
        }
        refreshSavedList();

        function applyChanges() {
          const type = $type.value;
          const stacked = $stacked.checked;

          // Parse JSON (multi-séries ok)
          const parsed = parseAnySeries($jsonEditor.value.trim());
          // stacking uniquement si type=column
          const stacking = (isColumnLike(type) && stacked) ? 'normal' : undefined;

          chart.update({
            plotOptions: { series: { stacking } },
            tooltip: { shared: true, split: false },
          }, false, true);

          // Synchroniser le nombre de séries
          const need = parsed.series.length;
          const have = chart.series.length;

          // Supprimer séries excédentaires
          for (let i=have-1; i>=need; i--) chart.series[i].remove(false);

          // Mettre à jour / créer
          parsed.series.forEach((s, idx) => {
            if (idx < chart.series.length) {
              chart.series[idx].update({ name: s.name, type, yAxis: yAxisIndexFor(type) }, false);
              chart.series[idx].setData(s.data, false);
            } else {
              chart.addSeries({ name: s.name, type, data: s.data, yAxis: yAxisIndexFor(type) }, false);
            }
          });

          chart.redraw();
          reflow();
        }

        // Auto-save courant pendant saisie
        let t; $jsonEditor.addEventListener('input', ()=>{
          clearTimeout(t);
          t = setTimeout(()=> lsSetCurrent($jsonEditor.value), 300);
        });

        document.getElementById('applyBtn').addEventListener('click', (e)=>{
          e.preventDefault();
          try { applyChanges(); }
          catch(err){ app.dialog.alert('JSON invalide : ' + err.message); }
        });

        document.getElementById('saveBtn').addEventListener('click', (e)=>{
          e.preventDefault();
          const name = ($name.value||'').trim();
          if (!name) { app.dialog.alert('Donne un nom pour sauvegarder.'); return; }
          const raw = $jsonEditor.value.trim();
          if (!raw) { app.dialog.alert('Le JSON est vide.'); return; }
          try { parseAnySeries(raw); } catch(err){ app.dialog.alert('JSON invalide : ' + err.message); return; }
          const map = lsGetSavedMap(); map[name] = raw; lsSetSavedMap(map);
          refreshSavedList(name);
          app.toast.create({ text: 'Sauvegardé', closeTimeout: 1500 }).open();
        });

        document.getElementById('loadBtn').addEventListener('click', (e)=>{
          e.preventDefault();
          const name = $list.value;
          if (!name) { app.dialog.alert('Sélectionne une sauvegarde.'); return; }
          const map = lsGetSavedMap(); const raw = map[name];
          if (!raw) { app.dialog.alert('Introuvable en localStorage.'); return; }
          $jsonEditor.value = raw; lsSetCurrent(raw);
          try { applyChanges(); } catch(err){ app.dialog.alert('JSON invalide : ' + err.message); }
        });

        document.getElementById('deleteBtn').addEventListener('click', (e)=>{
          e.preventDefault();
          const name = $list.value;
          if (!name) { app.dialog.alert('Sélectionne une sauvegarde à supprimer.'); return; }
          const map = lsGetSavedMap(); delete map[name]; lsSetSavedMap(map);
          refreshSavedList();
          app.toast.create({ text: 'Supprimé', closeTimeout: 1500 }).open();
        });

        // Upload JSON -> injecte dans l’éditeur (modifiable avant sauvegarde)
        $file.addEventListener('change', async (e)=>{
          const file = e.target.files?.[0]; if (!file) return;
          try {
            const text = await file.text();
            // Valide pour feedback rapide (multi-séries OK)
            parseAnySeries(text);
            $jsonEditor.value = text; lsSetCurrent(text);
            app.toast.create({ text: 'Fichier chargé (modifiable avant sauvegarde)', closeTimeout: 2000 }).open();
          } catch(err){
            app.dialog.alert('JSON invalide : ' + err.message);
          } finally { e.target.value = ''; }
        });

        // Changement type / stacked => appliquer direct (si JSON OK)
        document.getElementById('seriesType').addEventListener('change', () => { try { applyChanges(); } catch(e){} });
        document.getElementById('stackedColumns').addEventListener('change', () => { try { applyChanges(); } catch(e){} });
      }
    }
  });
</script>
</body>
</html>
