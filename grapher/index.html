<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Time Series Viewer (Highcharts Stock) — Datasets</title>

<!-- Highcharts Stock (CDN) -->
<script src="https://code.highcharts.com/stock/highstock.js"></script>
<script src="https://code.highcharts.com/stock/modules/data.js"></script>
<script src="https://code.highcharts.com/modules/exporting.js"></script>

<style>
  :root { --pad: 10px; --gap: 12px; }
  body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 0; }
  header { padding: var(--pad) calc(var(--pad)*2); background: #111; color: #fff; }
  main { padding: var(--pad) calc(var(--pad)*2); display: grid; gap: var(--gap); }
  .row { display: grid; grid-template-columns: 1fr; gap: var(--gap); }
  @media (min-width: 980px) { .row { grid-template-columns: 1.2fr 2fr; align-items: start; } }
  fieldset { border: 1px solid #ccc; padding: var(--pad); border-radius: 6px; }
  fieldset legend { padding: 0 6px; color: #555; }
  label { display: block; margin: 6px 0 4px; font-weight: 600; }
  input[type="text"], textarea, select { width: 100%; box-sizing: border-box; padding: 8px; font-family: inherit; }
  textarea { min-height: 160px; }
  .actions { display: flex; flex-wrap: wrap; gap: 8px; margin-top: 8px; }
  button { padding: 8px 12px; cursor: pointer; }
  .hint { color: #666; font-size: 0.9em; }
  .inline { display: inline-flex; gap: 8px; align-items: center; flex-wrap: wrap; }
  #chart { height: 520px; min-height: 320px; border: 1px solid #ddd; border-radius: 6px; }
  .saved { display: grid; grid-template-columns: 1fr auto auto; gap: 6px; align-items: center; }
  .muted { color: #777; }
  .ok { color: #0a7; }
  .err { color: #c33; }
  code.block { display:block; white-space:pre-wrap; background:#f7f7f7; padding:8px; border-radius:6px; border:1px solid #eee;}
</style>
</head>
<body>
<header>
  <h1>Time Series Viewer — Highcharts Stock (Datasets)</h1>
  <div class="hint">Paste/upload JSON (single or multiple series), render, <strong>auto‑save as a dataset</strong>, and reload.</div>
</header>

<main>
  <div class="row">
    <fieldset>
      <legend>Input</legend>

      <label for="datasetName">Dataset name (used when saving)</label>
      <input id="datasetName" type="text" placeholder="e.g., KPI 2023–2024" />

      <label for="defaultSeriesName">Default series name (only if the input provides none)</label>
      <input id="defaultSeriesName" type="text" placeholder="e.g., My Series" />

      <div class="inline">
        <div>
          <label for="fileInput">Upload JSON file</label>
          <input id="fileInput" type="file" accept=".json,.txt,application/json" />
        </div>
        <div class="muted">or paste JSON below</div>
      </div>

      <label for="jsonInput">JSON</label>
      <textarea id="jsonInput" placeholder='Examples:

// 1) Multi-series (map) -> saved as one dataset
{
  "Sales": [[1704067200000,100],[1706745600000,120]],
  "Cost":  [[1704067200000,80],[1706745600000,90]]
}

// 2) Multi-series (array) -> saved as one dataset
[
  { "name":"Sales", "data":[[1704067200000,100],[1706745600000,120]] },
  { "name":"Cost",  "data":[[1704067200000,80],[1706745600000,90]] }
]

// 3) Single series (pairs) -> dataset with one series
[[1704067200000,100],[1706745600000,120]]

// 4) Single series (objects) -> dataset with one series
[
  {"timestamp":"2024-01-01T00:00:00Z","value":100},
  {"timestamp":"2024-02-01T00:00:00Z","value":120}
]
'></textarea>

      <div class="actions">
        <button id="btnAdd">Add to chart</button>
        <button id="btnReplace">Replace chart</button>
        <button id="btnClearInput" title="Clear text area">Clear</button>
      </div>

      <div id="inputStatus" class="hint"></div>
      <div class="hint">
        <details>
          <summary>Accepted formats (click)</summary>
          <code class="block">
Map:   { "Name A": [[ts,val],...], "Name B": [[ts,val],...] }
Array: [ { "name":"Name A", "data":[[ts,val],...] }, ... ]
Pairs: [[ts,val], ...]
Objs:  [ {"timestamp": ISO8601|epoch_ms, "value": number}, ... ]
          </code>
        </details>
      </div>
    </fieldset>

    <fieldset>
      <legend>Chart</legend>

      <div class="inline" style="margin-bottom:8px">
        <label for="seriesType">Series type (auto-applies)</label>
        <select id="seriesType">
          <option value="spline" selected>spline</option>
          <option value="line">line</option>
          <option value="spline">spline</option>
          <option value="area">area</option>
          <option value="areaspline">areaspline</option>
          <option value="column">column</option>
          <option value="arearange">arearange (needs [low,high])</option>
        </select>

        <button id="btnResetZoom">Reset zoom</button>
        <span id="chartStatus" class="hint"></span>
      </div>

      <div id="chart"></div>
    </fieldset>
  </div>

  <fieldset>
    <legend>Saved datasets (localStorage)</legend>
    <div class="actions">
      <button id="btnExportAll">Export all datasets (JSON)</button>
      <button id="btnImportAll">Import datasets (JSON)</button>
      <button id="btnLoadAllSaved">Load all datasets</button>
      <button id="btnClearAll">Delete all</button>
      <input id="importAllInput" type="file" accept=".json" style="display:none" />
    </div>
    <div id="savedList" class="hint">No saved datasets yet.</div>
  </fieldset>
</main>

<script>
/* ---------------------- Storage (DATASETS) ---------------------- */
/**
 * Storage format:
 * STORAGE_KEY = 'ts_datasets_v1'
 * {
 *   "<datasetId>": {
 *     id, name, savedAt,
 *     series: [{ name, type, data:[[ts,val],...] }, ...]
 *   },
 *   ...
 * }
 */
const STORAGE_KEY = 'ts_datasets_v1';

function loadStore() {
  try { return JSON.parse(localStorage.getItem(STORAGE_KEY) || '{}'); }
  catch { return {}; }
}
function saveStore(store) {
  localStorage.setItem(STORAGE_KEY, JSON.stringify(store));
}
function upsertDataset(dataset) {
  const store = loadStore();
  store[dataset.id] = dataset;
  saveStore(store);
  renderSavedList();
}
function deleteDataset(id) {
  const store = loadStore();
  delete store[id];
  saveStore(store);
  renderSavedList();
}

/* ---------------------- Parsing ---------------------- */
function toMillis(ts) {
  if (typeof ts === 'number') return ts;          // assume epoch ms
  const n = Number(ts);
  if (!Number.isNaN(n) && n > 1e10) return n;     // numeric string ms
  const d = Date.parse(ts);                       // ISO
  if (!Number.isNaN(d)) return d;
  throw new Error('Unrecognized timestamp: ' + ts);
}

function normalizeDataArray(arr) {
  if (!Array.isArray(arr)) throw new Error('Series data must be an array');
  if (!arr.length) return [];
  if (Array.isArray(arr[0])) {
    return arr.map(p => [toMillis(p[0]), Number(p[1])]);
  } else {
    return arr.map(p => [toMillis(p.timestamp ?? p.time ?? p.t), Number(p.value ?? p.v)]);
  }
}

/**
 * parseInput(jsonText, defaultSeriesName) -> [{ name, data }]
 * Supports:
 * 1) Map:   { "A": [[ts,val],...], "B": [[ts,val],...] }
 * 2) Array: [ { name:"A", data:[[ts,val],...] }, ... ]
 * 3) Single: [[ts,val], ...]  or  [{timestamp,value}, ...]
 */
function parseInput(jsonText, defaultSeriesName) {
  const obj = JSON.parse(jsonText);

  if (obj && typeof obj === 'object' && !Array.isArray(obj)) {
    const out = [];
    for (const [name, data] of Object.entries(obj)) {
      out.push({ name, data: normalizeDataArray(data) });
    }
    if (!out.length) throw new Error('Empty object');
    return out;
  }

  if (Array.isArray(obj)) {
    if (obj.length && typeof obj[0] === 'object' && !Array.isArray(obj[0]) && ('name' in obj[0] || 'data' in obj[0])) {
      return obj.map((s, i) => {
        const name = s.name ?? `${defaultSeriesName || 'series'} ${i+1}`;
        const data = normalizeDataArray(s.data ?? s.values ?? s.series ?? []);
        return { name, data };
      });
    }
    const data = normalizeDataArray(obj);
    const name = defaultSeriesName || ('series ' + new Date().toISOString().replace('T',' ').replace('Z',''));
    return [{ name, data }];
  }

  throw new Error('Unsupported JSON format');
}

/* ---------------------- Chart ---------------------- */
let chart = Highcharts.stockChart('chart', {
  rangeSelector: { selected: 1 },
  title: { text: 'Time Series' },
  legend: { enabled: true },
  credits: { enabled: false },
  series: []
});

function addSeriesToChart(name, data, type) {
  return chart.addSeries({ name, data, type: type || currentSeriesType() });
}
function replaceChartWithSeries(seriesList) {
  while (chart.series.length) chart.series[0].remove(false);
  for (const s of seriesList) addSeriesToChart(s.name, s.data, s.type);
  chart.redraw();
}
function currentSeriesType() {
  return document.getElementById('seriesType').value || 'spline';
}

/* ---------------------- UI wiring ---------------------- */
const el = id => document.getElementById(id);

el('fileInput').addEventListener('change', async (e) => {
  const file = e.target.files?.[0];
  if (!file) return;
  const text = await file.text();
  el('jsonInput').value = text;
});

function defaults() {
  return {
    datasetName: (el('datasetName').value.trim() || `Dataset ${new Date().toLocaleString()}`),
    defaultSeriesName: (el('defaultSeriesName').value.trim() || 'series'),
    typeForNew: currentSeriesType()
  };
}

function tryParseAndReport() {
  const status = el('inputStatus');
  status.textContent = '';
  status.className = 'hint';
  try {
    const { defaultSeriesName } = defaults();
    const parsed = parseInput(el('jsonInput').value, defaultSeriesName);
    let points = 0, tMin = Infinity, tMax = -Infinity;
    for (const s of parsed) {
      if (!s.data.length) continue;
      points += s.data.length;
      tMin = Math.min(tMin, s.data[0][0]);
      tMax = Math.max(tMax, s.data[s.data.length-1][0]);
    }
    const span = (isFinite(tMin) && isFinite(tMax))
      ? `[${new Date(tMin).toISOString()} … ${new Date(tMax).toISOString()}]`
      : '';
    status.textContent = `Parsed ${parsed.length} series, ${points} points ${span}`;
    status.classList.add('ok');
    return parsed;
  } catch (err) {
    status.textContent = err.message;
    status.classList.add('err');
    throw err;
  }
}

/* ---- Add / Replace (and save as ONE DATASET) ---- */
function buildDatasetObject(datasetName, seriesList, typeForNew) {
  // Attach type to each series (use their own if provided; otherwise the current selector)
  const series = seriesList.map(s => ({
    name: s.name,
    type: s.type || typeForNew,
    data: s.data
  }));
  return {
    id: `${Date.now()}_${Math.random().toString(36).slice(2,8)}`,
    name: datasetName,
    savedAt: Date.now(),
    series
  };
}

el('btnAdd').addEventListener('click', () => {
  try {
    const parsed = tryParseAndReport();
    const { datasetName, typeForNew } = defaults();
    // Render
    for (const s of parsed) addSeriesToChart(s.name, s.data, s.type || typeForNew);
    chart.redraw();
    // Save as ONE dataset
    const ds = buildDatasetObject(datasetName, parsed, typeForNew);
    upsertDataset(ds);
    el('chartStatus').textContent = `Added ${parsed.length} series; saved dataset "${datasetName}".`;
  } catch {}
});

el('btnReplace').addEventListener('click', () => {
  try {
    const parsed = tryParseAndReport();
    const { datasetName, typeForNew } = defaults();
    const ds = buildDatasetObject(datasetName, parsed, typeForNew);
    // Replace chart
    replaceChartWithSeries(ds.series);
    // Save dataset
    upsertDataset(ds);
    el('chartStatus').textContent = `Replaced with ${parsed.length} series; saved dataset "${datasetName}".`;
  } catch {}
});

el('btnClearInput').addEventListener('click', () => {
  el('jsonInput').value = '';
  el('inputStatus').textContent = '';
});

/* ---- Auto-apply series type on change ---- */
el('seriesType').addEventListener('change', () => {
  const type = currentSeriesType();
  chart.series.forEach(s => s.update({ type }, false));
  chart.redraw();
  el('chartStatus').textContent = `Auto-applied type "${type}" to ${chart.series.length} series.`;
});

el('btnResetZoom').addEventListener('click', () => {
  chart.xAxis[0].setExtremes(null, null);
});

/* ---------------------- Saved datasets list ---------------------- */
function renderSavedList() {
  const container = el('savedList');
  const store = loadStore();
  const ids = Object.keys(store).sort((a,b)=>store[b].savedAt - store[a].savedAt);
  if (!ids.length) { container.innerHTML = 'No saved datasets yet.'; return; }

  const frag = document.createDocumentFragment();
  ids.forEach(id => {
    const ds = store[id];
    const row = document.createElement('div');
    row.className = 'saved';

    const info = document.createElement('div');
    const when = new Date(ds.savedAt).toLocaleString();
    const seriesCount = ds.series?.length ?? 0;
    info.innerHTML = `<strong>${ds.name}</strong> <span class="muted">— ${seriesCount} series • ${when}</span>`;

    const btnLoad = document.createElement('button');
    btnLoad.textContent = 'Load';
    btnLoad.title = 'Add this dataset to the chart';
    btnLoad.addEventListener('click', () => {
      for (const s of ds.series) addSeriesToChart(s.name, s.data, s.type || currentSeriesType());
      chart.redraw();
      el('chartStatus').textContent = `Loaded dataset "${ds.name}" (${seriesCount} series).`;
    });

    const btnDel = document.createElement('button');
    btnDel.textContent = 'Delete';
    btnDel.addEventListener('click', () => {
      if (confirm(`Delete dataset "${ds.name}"?`)) deleteDataset(id);
    });

    row.append(info, btnLoad, btnDel);
    frag.appendChild(row);
  });
  container.innerHTML = '';
  container.appendChild(frag);
}
renderSavedList();

/* ---------------------- Export / Import all datasets ---------------------- */
el('btnExportAll').addEventListener('click', () => {
  const blob = new Blob([JSON.stringify(loadStore(), null, 2)], { type: 'application/json' });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'time_series_datasets.json';
  a.click();
  URL.revokeObjectURL(a.href);
});

el('btnImportAll').addEventListener('click', () => el('importAllInput').click());
el('importAllInput').addEventListener('change', async (e) => {
  const file = e.target.files?.[0];
  if (!file) return;
  try {
    const text = await file.text();
    const obj = JSON.parse(text);
    if (!obj || typeof obj !== 'object' || Array.isArray(obj)) throw new Error('File must contain an object map of datasets');
    saveStore(obj);
    renderSavedList();
    alert('Imported datasets.');
  } catch (err) {
    alert('Import failed: ' + err.message);
  } finally {
    e.target.value = '';
  }
});

el('btnLoadAllSaved').addEventListener('click', () => {
  const store = loadStore();
  const ids = Object.keys(store);
  if (!ids.length) return alert('No saved datasets.');
  for (const id of ids) {
    const ds = store[id];
    for (const s of ds.series) addSeriesToChart(s.name, s.data, s.type || currentSeriesType());
  }
  chart.redraw();
  el('chartStatus').textContent = `Loaded ${ids.length} dataset(s).`;
});

el('btnClearAll').addEventListener('click', () => {
  if (!confirm('Delete ALL saved datasets in this browser?')) return;
  localStorage.removeItem(STORAGE_KEY);
  renderSavedList();
});

/* ---------------------- Seed example dataset (if none) ---------------------- */
(function seedExampleIfEmpty(){
  const store = loadStore();
  if (Object.keys(store).length) return;
  const start = Date.UTC(2024,0,1,0,0,0); // Jan 1, 2024
  const mk = (name, mult) => Array.from({length: 24}, (_,i)=>[
    start + i*30*24*3600e3,
    100 + Math.round((Math.sin(i/2)+Math.random()-0.5)*20*mult)
  ]);
  const ds = {
    id: `${Date.now()}_${Math.random().toString(36).slice(2,8)}`,
    name: 'Sample Dataset',
    savedAt: Date.now(),
    series: [
      { name: 'Sample A', type: 'spline', data: mk('A', 1) },
      { name: 'Sample B', type: 'spline', data: mk('B', 1.2) }
    ]
  };
  upsertDataset(ds);
})();
</script>
</body>
</html>
