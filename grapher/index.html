<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>TS Viewer</title>

<!-- Highcharts Stock -->
<script src="https://code.highcharts.com/stock/highstock.js"></script>

<style>
  :root { --gap: 10px; }
  * { box-sizing: border-box; }
  html, body { height: 100%; margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
  /* Sticky chart band at top */
  #chartWrap {
    position: sticky; top: 0; z-index: 10;
    background: #fff; /* avoids transparency artifacts while sticky */
    border-bottom: 1px solid #eee;
  }
  #chart { width: 100%; height: 62vh; min-height: 320px; }
  /* Controls under the chart */
  main { padding: 12px; display: grid; gap: var(--gap); }
  textarea, input[type="text"], select { width: 100%; padding: 8px; }
  textarea { min-height: 140px; resize: vertical; }
  .row { display: grid; gap: var(--gap); }
  .actions { display: flex; flex-wrap: wrap; gap: 8px; }
  button { padding: 8px 12px; cursor: pointer; }
  .series-controls { display: grid; gap: 8px; }
  .series-row { display: grid; grid-template-columns: 1fr 160px auto; gap: 8px; align-items: center; }
  .muted { color: #666; }
  details > summary { cursor: pointer; user-select: none; padding: 6px 0; }
</style>
</head>
<body>

<div id="chartWrap">
  <div id="chart"></div>
</div>

<main>
  <section class="row" aria-label="Input">
    <input id="datasetName" type="text" placeholder="Dataset name" />
    <input id="defaultSeriesName" type="text" placeholder="Default series name (if missing)" />
    <input id="fileInput" type="file" accept=".json,.txt,application/json" />
    <textarea id="jsonInput" placeholder='JSON here (map or array of series):
{
  "http-2xx": [[ts,val],...],
  "http-3xx": [[ts,val],...]
}
or
[
  {"name":"http-2xx","data":[[ts,val],...]},
  {"name":"http-3xx","data":[[ts,val],...]}
]'></textarea>
    <div class="actions">
      <button id="btnAdd">Add to chart</button>
      <button id="btnReplace">Replace chart</button>
      <button id="btnClearInput">Clear</button>
    </div>
    <div id="status" class="muted"></div>
  </section>

  <section aria-label="Per-series controls">
    <h3 style="margin:6px 0;">Series</h3>
    <div id="seriesControls" class="series-controls"></div>
  </section>

  <details>
    <summary>Saved datasets</summary>
    <div class="actions" style="margin:8px 0;">
      <button id="btnExportAll">Export all</button>
      <button id="btnImportAll">Import</button>
      <button id="btnLoadAllSaved">Load all</button>
      <button id="btnClearAll">Delete all</button>
      <input id="importAllInput" type="file" accept=".json" style="display:none" />
    </div>
    <div id="savedList" class="muted">No saved datasets yet.</div>
  </details>
</main>

<script>
/* ================== Storage & Active dataset ================== */
const STORAGE_KEY = 'ts_datasets_v5';
const ACTIVE_KEY  = 'ts_active_dataset_id';
function loadStore(){ try { return JSON.parse(localStorage.getItem(STORAGE_KEY)||'{}'); } catch { return {}; } }
function saveStore(s){ localStorage.setItem(STORAGE_KEY, JSON.stringify(s)); }
function getActiveId(){ return localStorage.getItem(ACTIVE_KEY) || null; }
function setActiveId(id){ localStorage.setItem(ACTIVE_KEY, id); renderSavedList(); }
function upsertDataset(ds){ const s=loadStore(); ds.updatedAt=Date.now(); s[ds.id]=ds; saveStore(s); if(!getActiveId()) setActiveId(ds.id); renderSavedList(); }
function deleteDataset(id){ const s=loadStore(); delete s[id]; saveStore(s); if(getActiveId()===id) localStorage.removeItem(ACTIVE_KEY); renderSavedList(); }
function patchActiveDataset(mut){ const s=loadStore(); const id=getActiveId(); if(!id||!s[id]) return; const ds=s[id]; mut(ds); ds.updatedAt=Date.now(); s[id]=ds; saveStore(s); renderSavedList(); }

/* ================== Parsing helpers ================== */
function toMillis(ts){ if(typeof ts==='number') return ts; const n=Number(ts); if(!Number.isNaN(n)&&n>1e10) return n; const d=Date.parse(ts); if(!Number.isNaN(d)) return d; throw new Error('Bad timestamp: '+ts); }
function normalizeDataArray(arr){
  if(!Array.isArray(arr)) throw new Error('Series data must be an array');
  if(!arr.length) return [];
  if(Array.isArray(arr[0])) return arr.map(p=>[toMillis(p[0]), Number(p[1])]);
  return arr.map(p=>[toMillis(p.timestamp??p.time??p.t), Number(p.value??p.v)]);
}
function parseInput(text, defaultName){
  const obj = JSON.parse(text);
  if(obj && typeof obj==='object' && !Array.isArray(obj)){
    const out=[]; for(const [name,data] of Object.entries(obj)) out.push({ name, data: normalizeDataArray(data) }); return out;
  }
  if(Array.isArray(obj)){
    if(obj.length && typeof obj[0]==='object' && !Array.isArray(obj[0]) && ('name' in obj[0] || 'data' in obj[0])){
      return obj.map((s,i)=>({ name: s.name ?? `${defaultName||'series'} ${i+1}`, data: normalizeDataArray(s.data ?? s.values ?? s.series ?? []) }));
    }
    return [{ name: defaultName || ('series '+new Date().toISOString()), data: normalizeDataArray(obj) }];
  }
  throw new Error('Unsupported JSON');
}

/* ================== Axis routing & stacking ================== */
function yAxisIndexForType(uiType){ return (uiType==='column'||uiType==='column-stacked') ? 0 : 1; }
function normalizeType(t){ if(t==='column-stacked') return { actualType:'column', stacked:true }; return { actualType:(t||'spline'), stacked:false }; }
function applyGlobalStacking(){ const any = chart.series.some(s=>s.userOptions && s.userOptions._uiType==='column-stacked'); chart.update({ plotOptions:{ column:{ stacking: any?'normal':null } } }, false); chart.redraw(); }

/* ================== Chart ================== */
let chart = Highcharts.stockChart('chart', {
  rangeSelector: { selected: 1 },
  title: { text: '' }, // no title (no distraction)
  credits: { enabled: false },
  legend: { enabled: true },
  tooltip: { shared: true, split: false },
  yAxis: [
    { title:{ text:'' }, opposite:false, alignTicks:true }, // 0: LEFT for columns
    { title:{ text:'' }, opposite:true,  alignTicks:true }  // 1: RIGHT for others
  ],
  plotOptions: { series: { turboThreshold: 0 }, column: { stacking: null } },
  series: []
});

function addSeriesToChart(name, data, uiType){
  const { actualType } = normalizeType(uiType);
  const yIdx = yAxisIndexForType(uiType||'spline');
  const s = chart.addSeries({ name, data, type: actualType, yAxis: yIdx });
  s.update({ _uiType: (uiType||'spline') }, false);
  return s;
}
function replaceChartWithSeries(seriesList){
  while(chart.series.length) chart.series[0].remove(false);
  for(const s of seriesList) addSeriesToChart(s.name, s.data, s.type);
  applyGlobalStacking();
  chart.redraw();
  refreshSeriesControls();
}

/* Snapshot chart -> dataset.series */
function snapshotChartSeries(){
  return chart.series.map(ser => ({
    name: ser.name,
    type: ser.userOptions && ser.userOptions._uiType ? ser.userOptions._uiType : ser.type,
    data: ser.options.data || []
  }));
}
function saveActiveFromChart(){ const id=getActiveId(); if(!id) return; patchActiveDataset(ds => { ds.series = snapshotChartSeries(); }); }

/* ================== UI ================== */
const el = id => document.getElementById(id);
const TYPE_OPTIONS = ['spline','line','area','areaspline','column','column-stacked'];

el('fileInput').addEventListener('change', async (e)=>{ const f=e.target.files?.[0]; if(!f) return; el('jsonInput').value = await f.text(); });

function defaults(){ return {
  datasetName: (el('datasetName').value.trim() || `Dataset ${new Date().toLocaleString()}`),
  defaultSeriesName: (el('defaultSeriesName').value.trim() || 'series')
};}

function tryParseAndReport(){
  const status = el('status'); status.textContent = '';
  const { defaultSeriesName } = defaults();
  const parsed = parseInput(el('jsonInput').value, defaultSeriesName);
  const n = parsed.reduce((a,s)=>a+(s.data?.length||0),0);
  status.textContent = `Parsed ${parsed.length} series, ${n} points.`;
  return parsed;
}

function buildDatasetObject(name, seriesList){
  return { id:`${Date.now()}_${Math.random().toString(36).slice(2,8)}`, name, savedAt: Date.now(), updatedAt: Date.now(), series: seriesList.map(s=>({ name:s.name, type:s.type||'spline', data:s.data })) };
}

el('btnAdd').addEventListener('click', () => {
  try {
    const parsed = tryParseAndReport();
    const { datasetName } = defaults();
    const list = parsed.map(s=>({ ...s, type: s.type || 'spline' }));
    for(const s of list) addSeriesToChart(s.name, s.data, s.type);
    applyGlobalStacking(); chart.redraw();
    const ds = buildDatasetObject(datasetName, list);
    upsertDataset(ds); setActiveId(ds.id); saveActiveFromChart();
    refreshSeriesControls();
  } catch(e){ el('status').textContent = e.message; }
});

el('btnReplace').addEventListener('click', () => {
  try {
    const parsed = tryParseAndReport();
    const { datasetName } = defaults();
    const list = parsed.map(s=>({ ...s, type: s.type || 'spline' }));
    replaceChartWithSeries(list);
    const ds = buildDatasetObject(datasetName, list);
    upsertDataset(ds); setActiveId(ds.id); saveActiveFromChart();
  } catch(e){ el('status').textContent = e.message; }
});

el('btnClearInput').addEventListener('click', ()=>{ el('jsonInput').value=''; el('status').textContent=''; });

function refreshSeriesControls(){
  const wrap = el('seriesControls'); wrap.innerHTML = '';
  if(!chart.series.length){ wrap.innerHTML = '<div class="muted">No series on chart.</div>'; return; }
  chart.series.forEach((s)=>{
    const row = document.createElement('div'); row.className='series-row';

    const nameEl = document.createElement('div'); nameEl.textContent = s.name;

    const sel = document.createElement('select');
    for(const t of TYPE_OPTIONS){ const o=document.createElement('option'); o.value=t; o.textContent=t; sel.appendChild(o); }
    const uiType = s.userOptions && s.userOptions._uiType ? s.userOptions._uiType
                 : (s.type==='column' && chart.options.plotOptions?.column?.stacking) ? 'column-stacked' : s.type;
    sel.value = uiType;

    sel.addEventListener('change', ()=>{
      const chosen = sel.value;
      const { actualType } = normalizeType(chosen);
      const yAxisIdx = yAxisIndexForType(chosen);
      s.update({ type: actualType, yAxis: yAxisIdx, _uiType: chosen }, false);
      applyGlobalStacking(); chart.redraw();
      saveActiveFromChart(); // live persist
    });

    const btnRemove = document.createElement('button'); btnRemove.textContent='Remove';
    btnRemove.addEventListener('click', ()=>{
      s.remove(false); chart.redraw(); refreshSeriesControls(); applyGlobalStacking(); saveActiveFromChart();
    });

    row.append(nameEl, sel, btnRemove);
    wrap.appendChild(row);
  });
}

/* ================== Saved datasets (collapsed) ================== */
function renderSavedList(){
  const container = document.getElementById('savedList');
  const s = loadStore(); const active = getActiveId();
  const ids = Object.keys(s).sort((a,b)=>(s[b].updatedAt??s[b].savedAt)-(s[a].updatedAt??s[a].savedAt));
  if(!ids.length){ container.textContent='No saved datasets yet.'; return; }
  const frag = document.createDocumentFragment();
  ids.forEach(id=>{
    const ds=s[id];
    const div=document.createElement('div');
    div.innerHTML = `<strong>${ds.name}</strong> <span class="muted">(${ds.series?.length||0} series)</span>` + (id===active?' <span class="muted">• active</span>':'');
    const btnLoad=document.createElement('button'); btnLoad.textContent='Load';
    btnLoad.addEventListener('click', ()=>{
      ds.series.forEach(sdef=>addSeriesToChart(sdef.name, sdef.data, sdef.type||'spline'));
      applyGlobalStacking(); chart.redraw(); refreshSeriesControls(); setActiveId(id); saveActiveFromChart();
    });
    const btnDel=document.createElement('button'); btnDel.textContent='Delete';
    btnDel.addEventListener('click', ()=>{ if(confirm(`Delete "${ds.name}"?`)) deleteDataset(id); });
    const row=document.createElement('div'); row.className='actions'; row.append(btnLoad, btnDel);
    div.appendChild(row); frag.appendChild(div);
  });
  container.innerHTML=''; container.appendChild(frag);
}
renderSavedList();

/* Export / Import / Bulk load / Clear */
document.getElementById('btnExportAll').addEventListener('click', ()=>{
  const blob = new Blob([JSON.stringify(loadStore(), null, 2)], { type:'application/json' });
  const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='time_series_datasets.json'; a.click(); URL.revokeObjectURL(a.href);
});
document.getElementById('btnImportAll').addEventListener('click', ()=>document.getElementById('importAllInput').click());
document.getElementById('importAllInput').addEventListener('change', async (e)=>{
  const f=e.target.files?.[0]; if(!f) return;
  try{ const text=await f.text(); const obj=JSON.parse(text); if(!obj||typeof obj!=='object'||Array.isArray(obj)) throw new Error('File must contain an object map of datasets'); saveStore(obj); renderSavedList(); alert('Imported.'); }
  catch(err){ alert('Import failed: '+err.message); }
  finally{ e.target.value=''; }
});
document.getElementById('btnLoadAllSaved').addEventListener('click', ()=>{
  const s=loadStore(); const ids=Object.keys(s); if(!ids.length) return alert('No saved datasets.');
  ids.forEach(id=>{ const ds=s[id]; ds.series.forEach(sd=>addSeriesToChart(sd.name, sd.data, sd.type||'spline')); });
  applyGlobalStacking(); chart.redraw(); refreshSeriesControls(); setActiveId(ids[ids.length-1]); saveActiveFromChart();
});
document.getElementById('btnClearAll').addEventListener('click', ()=>{
  if(!confirm('Delete ALL saved datasets in this browser?')) return;
  localStorage.removeItem(STORAGE_KEY); localStorage.removeItem(ACTIVE_KEY); renderSavedList();
});
</script>
</body>
</html>
