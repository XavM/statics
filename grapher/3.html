<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport"
      content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>TS Viewer</title>

<!-- Highcharts Stock -->
<script src="https://code.highcharts.com/stock/highstock.js"></script>

<style>
  :root { --gap: 10px; --fab: 56px; }

  /* No page scrolling, ever */
  html, body {
    margin: 0;
    padding: 0;
    height: 100%;
    overflow: hidden;               /* bloque scroll global */
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    background: #fff;
  }

  /* Fullscreen chart container */
  #chartWrap {
    position: relative;
    width: 100vw;
    height: 100dvh;                 /* occupe toute la hauteur visible */
    height: -webkit-fill-available; /* iOS fallback */
  }
  #chart {
    width: 100%;
    height: 100%;
    min-height: 320px;
  }

  /* Floating Action Button */
  #fab {
    position: fixed;
    right: 16px;
    bottom: 16px;
    width: var(--fab);
    height: var(--fab);
    border-radius: 50%;
    border: none;
    box-shadow: 0 4px 12px rgba(0,0,0,.2);
    background: #1976d2;
    color: #fff;
    font-size: 28px;
    line-height: 1;
    cursor: pointer;
    z-index: 20;
  }

  /* Slide-over panel (pure CSS/Dialog) */
  dialog#panel {
    border: none;
    padding: 0;
    margin: 0;
    width: 100vw;
    max-width: 900px;
    height: 100dvh;
    height: -webkit-fill-available;
    inset: 0 0 0 auto;              /* anchor to right */
    position: fixed;
    transform: translateX(100%);
    transition: transform .25s ease;
    background: #fff;
    z-index: 30;
  }
  dialog#panel[open] { transform: translateX(0); }
  dialog::backdrop {
    background: rgba(0,0,0,.2);
  }

  /* Panel content */
  .panel-head {
    display: flex; align-items: center; justify-content: space-between;
    padding: 12px 16px; border-bottom: 1px solid #eee;
    position: sticky; top: 0; background: #fff; z-index: 1;
  }
  .panel-body {
    height: calc(100% - 54px);
    overflow: auto;                 /* le panneau scrolle, pas la page */
    padding: 12px 16px 24px;
    display: grid;
    gap: 14px;
  }

  textarea, input[type="text"], select { width: 100%; padding: 8px; }
  textarea { min-height: 140px; resize: vertical; }
  .actions { display: flex; flex-wrap: wrap; gap: 8px; }
  button { padding: 8px 12px; cursor: pointer; }

  /* Series table */
  table { width: 100%; border-collapse: collapse; }
  th, td { text-align: left; padding: 8px; border-bottom: 1px solid #eee; }
  th { position: sticky; top: 0; background: #fafafa; z-index: 1; }
  .muted { color: #666; }

  /* Utility sections */
  details > summary { cursor: pointer; user-select: none; padding: 6px 0; }
</style>
</head>
<body>

<!-- FULLSCREEN CHART ONLY -->
<div id="chartWrap"><div id="chart"></div></div>

<!-- FLOATING ACTION BUTTON -->
<button id="fab" title="Open controls">â‰¡</button>

<!-- SLIDE-OVER PANEL (inputs + series table + saved datasets) -->
<dialog id="panel">
  <div class="panel-head">
    <strong>Controls</strong>
    <div>
      <button id="btnClose">Close</button>
    </div>
  </div>
  <div class="panel-body">

    <section aria-label="Input">
      <input id="datasetName" type="text" placeholder="Dataset name" />
      <input id="defaultSeriesName" type="text" placeholder="Default series name (if missing)" />
      <input id="fileInput" type="file" accept=".json,.txt,application/json" />
      <textarea id="jsonInput" placeholder='JSON here (map or array of series). "_meta" or "meta" keys are ignored.'></textarea>
      <div class="actions">
        <button id="btnAdd">Add to chart</button>
        <button id="btnReplace">Replace chart</button>
        <button id="btnClearInput">Clear</button>
      </div>
      <div id="status" class="muted"></div>
    </section>

    <section aria-label="Series table">
      <h3 style="margin:6px 0;">Series</h3>
      <div id="seriesTableWrap" class="muted">No series on chart.</div>
    </section>

    <details>
      <summary>Saved datasets</summary>
      <div class="actions" style="margin:8px 0;">
        <button id="btnExportAll">Export all</button>
        <button id="btnImportAll">Import</button>
        <button id="btnLoadAllSaved">Load all</button>
        <button id="btnClearAll">Delete all</button>
        <input id="importAllInput" type="file" accept=".json" style="display:none" />
      </div>
      <div id="savedList" class="muted">No saved datasets yet.</div>
    </details>
  </div>
</dialog>

<script>
/* ================== Storage & Active dataset ================== */
const STORAGE_KEY = 'ts_datasets_v7';
const ACTIVE_KEY  = 'ts_active_dataset_id';
function loadStore(){ try { return JSON.parse(localStorage.getItem(STORAGE_KEY)||'{}'); } catch { return {}; } }
function saveStore(s){ localStorage.setItem(STORAGE_KEY, JSON.stringify(s)); }
function getActiveId(){ return localStorage.getItem(ACTIVE_KEY) || null; }
function setActiveId(id){ localStorage.setItem(ACTIVE_KEY, id); renderSavedList(); }
function upsertDataset(ds){ const s=loadStore(); ds.updatedAt=Date.now(); s[ds.id]=ds; saveStore(s); if(!getActiveId()) setActiveId(ds.id); renderSavedList(); }
function deleteDataset(id){ const s=loadStore(); delete s[id]; saveStore(s); if(getActiveId()===id) localStorage.removeItem(ACTIVE_KEY); renderSavedList(); }
function patchActiveDataset(mut){
  const s=loadStore(); const id=getActiveId(); if(!id||!s[id]) return;
  const ds=s[id]; mut(ds); ds.updatedAt=Date.now(); s[id]=ds; saveStore(s); renderSavedList();
}

/* ================== Parsing helpers ================== */
function toMillis(ts){
  if (typeof ts === 'number') return ts < 1e12 ? Math.round(ts*1000) : Math.round(ts);
  const n = Number(ts);
  if (!Number.isNaN(n)) return n < 1e12 ? Math.round(n*1000) : Math.round(n);
  const d = Date.parse(ts); if(!Number.isNaN(d)) return d;
  throw new Error('Bad timestamp: '+ts);
}
function normalizeDataArray(arr){
  if(!Array.isArray(arr)) throw new Error('Series data must be an array');
  if(!arr.length) return [];
  if(Array.isArray(arr[0])) return arr.map(p=>[toMillis(p[0]), Number(p[1])]);
  return arr.map(p=>[toMillis(p.timestamp??p.time??p.t), Number(p.value??p.v)]);
}
function parseInput(text, defaultName){
  const obj = JSON.parse(text);
  if(obj && typeof obj==='object' && !Array.isArray(obj)){
    const out=[];
    for(const [name,data] of Object.entries(obj)){
      if (name === '_meta' || name === 'meta') continue;
      out.push({ name, data: normalizeDataArray(data) });
    }
    return out;
  }
  if(Array.isArray(obj)){
    if(obj.length && typeof obj[0]==='object' && !Array.isArray(obj[0]) && ('name' in obj[0] || 'data' in obj[0])){
      return obj.map((s,i)=>({ name: s.name ?? `${defaultName||'series'} ${i+1}`, data: normalizeDataArray(s.data ?? s.values ?? s.series ?? []) }));
    }
    return [{ name: defaultName || ('series '+new Date().toISOString()), data: normalizeDataArray(obj) }];
  }
  throw new Error('Unsupported JSON');
}

/* ================== Axis routing & stacking ================== */
function yAxisIndexForType(uiType){ return (uiType==='column'||uiType==='column-stacked') ? 0 : 1; }
function normalizeType(t){ return (t==='column-stacked') ? { actualType:'column', stacked:true } : { actualType:(t||'spline'), stacked:false }; }
function applyGlobalStacking(){
  const any = chart.series.some(s=> (s.userOptions && s.userOptions._uiType==='column-stacked'));
  chart.update({ plotOptions:{ column:{ stacking: any ? 'normal' : null } } }, false);
}

/* ================== Aggregations (metadata only for now) ================== */
const AGG_OPTIONS = ['none','sum','avg','min','max','stdev'];

/* ================== Chart ================== */
let chart = Highcharts.stockChart('chart', {
  rangeSelector: { selected: 1 },
  title: { text: '' },
  credits: { enabled: false },
  legend: { enabled: true },
  tooltip: { shared: true, split: false },
  yAxis: [
    { title:{ text:'' }, opposite:false, alignTicks:true }, // left
    { title:{ text:'' }, opposite:true,  alignTicks:true }  // right
  ],
  plotOptions: { series: { turboThreshold: 0 }, column: { stacking: null } },
  series: []
});

function addSeriesToChart(name, data, uiType, agg='none'){
  const { actualType } = normalizeType(uiType);
  const yIdx = yAxisIndexForType(uiType||'spline');
  const s = chart.addSeries({ name, data, type: actualType, yAxis: yIdx }, false);
  s.update({ _uiType: (uiType||'spline'), _agg: agg }, false); // store UI type + aggregation as custom flags
  return s;
}
function replaceChartWithSeries(seriesList){
  while(chart.series.length) chart.series[0].remove(false);
  for(const s of seriesList) addSeriesToChart(s.name, s.data, s.type, s.agg||'none');
  applyGlobalStacking();
  chart.redraw();
  buildSeriesTable();
}

/* Snapshot chart -> dataset.series */
function snapshotChartSeries(){
  return chart.series.map(ser => ({
    name: ser.name,
    type: (ser.userOptions && ser.userOptions._uiType) ? ser.userOptions._uiType : ser.type,
    agg:  (ser.userOptions && ser.userOptions._agg)     ? ser.userOptions._agg     : 'none',
    data: (ser.options && Array.isArray(ser.options.data) && ser.options.data.length)
           ? ser.options.data
           : ser.points?.map(p=>[p.x, p.y]) || []
  }));
}
function saveActiveFromChart(){
  const id=getActiveId(); if(!id) return;
  patchActiveDataset(ds => { ds.series = snapshotChartSeries(); });
}

/* ================== UI: FAB + Panel ================== */
const panel = document.getElementById('panel');
document.getElementById('fab').addEventListener('click', ()=> panel.showModal());
document.getElementById('btnClose').addEventListener('click', ()=> panel.close());

/* ================== Inputs & actions ================== */
const el = id => document.getElementById(id);
const TYPE_OPTIONS = ['spline','line','area','areaspline','column','column-stacked'];

el('fileInput').addEventListener('change', async (e)=>{
  const f=e.target.files?.[0]; if(!f) return;
  el('jsonInput').value = await f.text();
});

function defaults(){ return {
  datasetName: (el('datasetName').value.trim() || `Dataset ${new Date().toLocaleString()}`),
  defaultSeriesName: (el('defaultSeriesName').value.trim() || 'series')
};}

function tryParseAndReport(){
  const status = el('status'); status.textContent = '';
  const { defaultSeriesName } = defaults();
  const parsed = parseInput(el('jsonInput').value, defaultSeriesName);
  const n = parsed.reduce((a,s)=>a+(s.data?.length||0),0);
  status.textContent = `Parsed ${parsed.length} series, ${n} points.`;
  return parsed;
}

function buildDatasetObject(name, seriesList){
  return {
    id:`${Date.now()}_${Math.random().toString(36).slice(2,8)}`,
    name, savedAt: Date.now(), updatedAt: Date.now(),
    series: seriesList.map(s=>({ name:s.name, type:s.type||'spline', agg:s.agg||'none', data:s.data }))
  };
}

function persistAndActivate(list, datasetName){
  const ds = buildDatasetObject(datasetName, list);
  upsertDataset(ds); setActiveId(ds.id);
  saveActiveFromChart();
  buildSeriesTable();
}

el('btnAdd').addEventListener('click', () => {
  try {
    const parsed = tryParseAndReport();
    const { datasetName } = defaults();
    const list = parsed.map(s=>({ ...s, type: s.type || 'spline', agg: s.agg || 'none' }));
    for(const s of list) addSeriesToChart(s.name, s.data, s.type, s.agg);
    applyGlobalStacking(); chart.redraw();
    persistAndActivate(list, datasetName);
  } catch(e){ el('status').textContent = e.message; }
});

el('btnReplace').addEventListener('click', () => {
  try {
    const parsed = tryParseAndReport();
    const { datasetName } = defaults();
    const list = parsed.map(s=>({ ...s, type: s.type || 'spline', agg: s.agg || 'none' }));
    replaceChartWithSeries(list);
    persistAndActivate(list, datasetName);
  } catch(e){ el('status').textContent = e.message; }
});

el('btnClearInput').addEventListener('click', ()=>{
  el('jsonInput').value=''; el('status').textContent='';
});

/* ================== Series table (editable) ================== */
function buildSeriesTable(){
  const wrap = document.getElementById('seriesTableWrap');
  if(!chart.series.length){ wrap.innerHTML = '<div class="muted">No series on chart.</div>'; return; }

  const tbl = document.createElement('table');
  const thead = document.createElement('thead');
  thead.innerHTML = `
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Aggregation</th>
      <th></th>
    </tr>`;
  const tbody = document.createElement('tbody');

  chart.series.forEach((s)=>{
    const tr = document.createElement('tr');

    // Name (inline edit on click)
    const tdName = document.createElement('td');
    const nameInput = document.createElement('input');
    nameInput.type = 'text'; nameInput.value = s.name;
    nameInput.addEventListener('change', ()=>{
      s.update({ name: nameInput.value }, false);
      chart.redraw(); saveActiveFromChart(); renderSavedList();
    });
    tdName.appendChild(nameInput);

    // Type dropdown
    const tdType = document.createElement('td');
    const selType = document.createElement('select');
    TYPE_OPTIONS.forEach(t=>{
      const o=document.createElement('option'); o.value=t; o.textContent=t; selType.appendChild(o);
    });
    const uiType = s.userOptions && s.userOptions._uiType
      ? s.userOptions._uiType
      : (s.type==='column' && chart.options.plotOptions?.column?.stacking) ? 'column-stacked' : s.type;
    selType.value = uiType;
    selType.addEventListener('change', ()=>{
      const chosen = selType.value;
      const { actualType } = normalizeType(chosen);
      const yAxisIdx = yAxisIndexForType(chosen);
      s.update({ type: actualType, yAxis: yAxisIdx, _uiType: chosen }, false);
      applyGlobalStacking(); chart.redraw(); saveActiveFromChart();
    });
    tdType.appendChild(selType);

    // Aggregation dropdown
    const tdAgg = document.createElement('td');
    const selAgg = document.createElement('select');
    AGG_OPTIONS.forEach(a=>{
      const o=document.createElement('option'); o.value=a; o.textContent=a; selAgg.appendChild(o);
    });
    selAgg.value = (s.userOptions && s.userOptions._agg) ? s.userOptions._agg : 'none';
    selAgg.addEventListener('change', ()=>{
      s.update({ _agg: selAgg.value }, false);
      chart.redraw(); saveActiveFromChart();
    });
    tdAgg.appendChild(selAgg);

    // Remove button
    const tdAct = document.createElement('td');
    const btnRemove = document.createElement('button'); btnRemove.textContent='Remove';
    btnRemove.addEventListener('click', ()=>{
      s.remove(false);
      applyGlobalStacking(); chart.redraw();
      buildSeriesTable(); saveActiveFromChart();
    });
    tdAct.appendChild(btnRemove);

    tr.append(tdName, tdType, tdAgg, tdAct);
    tbody.appendChild(tr);
  });

  tbl.append(thead, tbody);
  wrap.innerHTML = '';
  wrap.appendChild(tbl);
}

/* ================== Saved datasets ================== */
function renderSavedList(){
  const container = document.getElementById('savedList');
  const s = loadStore(); const active = getActiveId();
  const ids = Object.keys(s).sort((a,b)=>(s[b].updatedAt??s[b].savedAt)-(s[a].updatedAt??s[a].savedAt));
  if(!ids.length){ container.textContent='No saved datasets yet.'; return; }
  const frag = document.createDocumentFragment();
  ids.forEach(id=>{
    const ds=s[id];
    const div=document.createElement('div');
    div.innerHTML = `<strong>${ds.name}</strong> <span class="muted">(${ds.series?.length||0} series)</span>` + (id===active?' <span class="muted">â€¢ active</span>':'');
    const btnLoad=document.createElement('button'); btnLoad.textContent='Load';
    btnLoad.addEventListener('click', ()=>{
      ds.series.forEach(sdef=>addSeriesToChart(sdef.name, sdef.data, sdef.type||'spline', sdef.agg||'none'));
      applyGlobalStacking(); chart.redraw();
      setActiveId(id); saveActiveFromChart();
      buildSeriesTable();
    });
    const btnDel=document.createElement('button'); btnDel.textContent='Delete';
    btnDel.addEventListener('click', ()=>{ if(confirm(`Delete "${ds.name}"?`)) deleteDataset(id); buildSeriesTable(); });
    const row=document.createElement('div'); row.className='actions'; row.append(btnLoad, btnDel);
    div.appendChild(row); frag.appendChild(div);
  });
  container.innerHTML=''; container.appendChild(frag);
}
renderSavedList();

/* Export / Import / Bulk load / Clear */
document.getElementById('btnExportAll').addEventListener('click', ()=>{
  const blob = new Blob([JSON.stringify(loadStore(), null, 2)], { type:'application/json' });
  const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='time_series_datasets.json'; a.click(); URL.revokeObjectURL(a.href);
});
document.getElementById('btnImportAll').addEventListener('click', ()=>document.getElementById('importAllInput').click());
document.getElementById('importAllInput').addEventListener('change', async (e)=>{
  const f=e.target.files?.[0]; if(!f) return;
  try{
    const text=await f.text();
    const obj=JSON.parse(text);
    if(!obj||typeof obj!=='object'||Array.isArray(obj)) throw new Error('File must contain an object map of datasets');
    saveStore(obj); renderSavedList(); alert('Imported.');
  } catch(err){ alert('Import failed: '+err.message); }
  finally{ e.target.value=''; }
});
document.getElementById('btnLoadAllSaved').addEventListener('click', ()=>{
  const s=loadStore(); const ids=Object.keys(s); if(!ids.length) return alert('No saved datasets.');
  ids.forEach(id=>{ const ds=s[id]; ds.series.forEach(sd=>addSeriesToChart(sd.name, sd.data, sd.type||'spline', sd.agg||'none')); });
  applyGlobalStacking(); chart.redraw(); setActiveId(ids[ids.length-1]); saveActiveFromChart(); buildSeriesTable();
});
document.getElementById('btnClearAll').addEventListener('click', ()=>{
  if(!confirm('Delete ALL saved datasets in this browser?')) return;
  localStorage.removeItem(STORAGE_KEY); localStorage.removeItem(ACTIVE_KEY); renderSavedList(); buildSeriesTable();
});

/* Init empty table */
buildSeriesTable();
</script>
</body>
</html>
