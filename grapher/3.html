<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>TS Viewer</title>

<script src="https://code.highcharts.com/stock/highstock.js"></script>

<style>
  :root { --gap: 10px; --fab: 56px; }
  html, body { margin:0; padding:0; height:100%; overflow:hidden; font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; background:#fff; }
  /* Fullscreen chart */
  #chartWrap { position:relative; width:100vw; height:100dvh; height:-webkit-fill-available; }
  #chart { width:100%; height:100%; min-height:320px; }
  /* Floating Action Button */
  #fab { position:fixed; right:16px; bottom:16px; width:var(--fab); height:var(--fab); border-radius:50%; border:none; box-shadow:0 4px 12px rgba(0,0,0,.2); background:#1976d2; color:#fff; font-size:28px; line-height:1; cursor:pointer; z-index:20; }
  /* Slide-over panel */
  dialog#panel { border:none; padding:0; margin:0; width:100vw; max-width:900px; height:100dvh; height:-webkit-fill-available; inset:0 0 0 auto; position:fixed; transform:translateX(100%); transition:transform .25s ease; background:#fff; z-index:30; }
  dialog#panel[open]{ transform:translateX(0); }
  dialog::backdrop{ background:rgba(0,0,0,.2); }
  .panel-head{ display:flex; align-items:center; justify-content:space-between; padding:12px 16px; border-bottom:1px solid #eee; position:sticky; top:0; background:#fff; z-index:1; }
  .panel-body{ height:calc(100% - 54px); overflow:auto; padding:12px 16px 24px; display:grid; gap:14px; }
  textarea,input[type="text"],select{ width:100%; padding:8px; } textarea{ min-height:140px; resize:vertical; }
  .actions{ display:flex; flex-wrap:wrap; gap:8px; } button{ padding:8px 12px; cursor:pointer; }
  table{ width:100%; border-collapse:collapse; } th,td{ text-align:left; padding:8px; border-bottom:1px solid #eee; } th{ position:sticky; top:0; background:#fafafa; z-index:1; }
  .muted{ color:#666; } details>summary{ cursor:pointer; user-select:none; padding:6px 0; }
</style>
</head>
<body>

<!-- FULLSCREEN CHART -->
<div id="chartWrap"><div id="chart"></div></div>
<button id="fab" title="Open controls">≡</button>

<!-- PANEL -->
<dialog id="panel">
  <div class="panel-head">
    <strong>Controls</strong>
    <div><button id="btnClose">Close</button></div>
  </div>
  <div class="panel-body">
    <section aria-label="Input">
      <input id="datasetName" type="text" placeholder="Dataset name" />
      <input id="defaultSeriesName" type="text" placeholder="Default series name (if missing)" />
      <input id="fileInput" type="file" accept=".json,.txt,application/json" />
      <textarea id="jsonInput" placeholder='JSON here (map or array of series). Keys "_meta"/"meta" ignored.'></textarea>
      <div class="actions">
        <button id="btnAdd">Add to chart</button>
        <button id="btnReplace">Replace chart</button>
        <button id="btnClearInput">Clear</button>
      </div>
      <div id="status" class="muted"></div>
    </section>

    <section aria-label="Series table">
      <h3 style="margin:6px 0;">Series</h3>
      <div id="seriesTableWrap" class="muted">No series on chart.</div>
    </section>

    <details>
      <summary>Saved datasets</summary>
      <div class="actions" style="margin:8px 0;">
        <button id="btnExportAll">Export all</button>
        <button id="btnImportAll">Import</button>
        <button id="btnLoadAllSaved">Load all</button>
        <button id="btnClearAll">Delete all</button>
        <input id="importAllInput" type="file" accept=".json" style="display:none" />
      </div>
      <div id="savedList" class="muted">No saved datasets yet.</div>
    </details>
  </div>
</dialog>

<script>
/* ================== localStorage granular ================== */
const INDEX_KEY  = 'ts_ds_index_v2';
const DS_PREFIX  = 'ts_ds_';
const ACTIVE_KEY = 'ts_active_dataset_id';

function lsGet(k){ return localStorage.getItem(k); }
function lsSet(k,v){ localStorage.setItem(k,v); }
function lsDel(k){ localStorage.removeItem(k); }

function loadIndex(){ try{ return JSON.parse(lsGet(INDEX_KEY)||'[]'); }catch{ return []; } }
function saveIndex(ids){ lsSet(INDEX_KEY, JSON.stringify(ids)); }
function listIds(){ return loadIndex(); }

function getDataset(id){
  try{ const raw=lsGet(DS_PREFIX+id); return raw?JSON.parse(raw):null; }catch{ return null; }
}
function saveDataset(ds){
  // may throw QuotaExceededError -> caller handles it
  lsSet(DS_PREFIX+ds.id, JSON.stringify(ds));
  const ids=loadIndex(); if(!ids.includes(ds.id)){ ids.push(ds.id); saveIndex(ids); }
}
function deleteDataset(id){
  lsDel(DS_PREFIX+id);
  saveIndex(loadIndex().filter(x=>x!==id));
}
function getAllMetas(){
  return listIds().map(id=>{
    const ds=getDataset(id);
    return ds?{id, name:ds.name, updatedAt:ds.updatedAt||ds.savedAt||0, count:ds.series?.length||0}:null;
  }).filter(Boolean).sort((a,b)=>b.updatedAt-a.updatedAt);
}

/* ================== Parse helpers ================== */
function toMillis(ts){
  if (typeof ts === 'number') return ts < 1e12 ? Math.round(ts*1000) : Math.round(ts);
  const n = Number(ts); if (!Number.isNaN(n)) return n < 1e12 ? Math.round(n*1000) : Math.round(n);
  const d = Date.parse(ts); if(!Number.isNaN(d)) return d;
  throw new Error('Bad timestamp: '+ts);
}
function normalizeDataArray(arr){
  if(!Array.isArray(arr)) throw new Error('Series data must be an array');
  if(!arr.length) return [];
  if(Array.isArray(arr[0])) return arr.map(p=>[toMillis(p[0]), Number(p[1])]);
  return arr.map(p=>[toMillis(p.timestamp??p.time??p.t), Number(p.value??p.v)]);
}
function parseInput(text, defaultName){
  const obj = JSON.parse(text);
  if(obj && typeof obj==='object' && !Array.isArray(obj)){
    const out=[]; for(const [name,data] of Object.entries(obj)){ if(name==='_meta'||name==='meta') continue; out.push({ name, data: normalizeDataArray(data) }); }
    return out;
  }
  if(Array.isArray(obj)){
    if(obj.length && typeof obj[0]==='object' && !Array.isArray(obj[0]) && ('name' in obj[0] || 'data' in obj[0])){
      return obj.map((s,i)=>({ name: s.name ?? `${defaultName||'series'} ${i+1}`, data: normalizeDataArray(s.data ?? s.values ?? s.series ?? []) }));
    }
    return [{ name: defaultName || ('series '+new Date().toISOString()), data: normalizeDataArray(obj) }];
  }
  throw new Error('Unsupported JSON');
}

/* ================== Build dataset(s) from ANY JSON ================== */
function buildDatasetObject(name, seriesList){
  return {
    id:`${Date.now()}_${Math.random().toString(36).slice(2,8)}`,
    name, savedAt: Date.now(), updatedAt: Date.now(),
    series: seriesList.map(s=>({ name:s.name, type:s.type||'spline', data:s.data }))
  };
}
// Accept dump of datasets OR plain series JSON (like your file).
function datasetsFromAnyJson(obj, nameHint){
  const makeId = () => `${Date.now()}_${Math.random().toString(36).slice(2,8)}`;

  // Single dataset object?
  if (obj && typeof obj==='object' && !Array.isArray(obj) && Array.isArray(obj.series)) {
    const ds = { ...obj };
    if (!ds.id) ds.id = makeId();
    if (!ds.name) ds.name = nameHint || 'Imported dataset';
    return [ds];
  }
  // Map id->dataset?
  if (obj && typeof obj==='object' && !Array.isArray(obj)) {
    const vals = Object.values(obj);
    if (vals.length && vals.every(v => v && typeof v==='object' && Array.isArray(v.series))) {
      return vals.map(v => ({ ...v, id: v.id || makeId(), name: v.name || nameHint || 'Imported dataset' }));
    }
    // Map of series -> dataset
    const parsed = parseInput(JSON.stringify(obj), 'series');
    const list = parsed.map(s=>({ name:s.name, type:s.type||'spline', data:s.data }));
    return [buildDatasetObject(nameHint || `Imported ${new Date().toLocaleString()}`, list)];
  }
  // Array (datasets or series)
  if (Array.isArray(obj)) {
    if (obj.length && obj[0] && typeof obj[0]==='object' && Array.isArray(obj[0].series)) {
      return obj.map(v => ({ ...v, id: v.id || makeId(), name: v.name || nameHint || 'Imported dataset' }));
    }
    const parsed = parseInput(JSON.stringify(obj), 'series');
    const list = parsed.map(s=>({ name:s.name, type:s.type||'spline', data:s.data }));
    return [buildDatasetObject(nameHint || `Imported ${new Date().toLocaleString()}`, list)];
  }
  throw new Error('Unsupported JSON');
}

/* ================== Chart ================== */
function yAxisIndexForType(uiType){ return (uiType==='column'||uiType==='column-stacked') ? 0 : 1; }
function normalizeType(t){ return (t==='column-stacked') ? { actualType:'column', stacked:true } : { actualType:(t||'spline'), stacked:false }; }
function applyGlobalStacking(){
  const any = chart.series.some(s=> (s.userOptions && s.userOptions._uiType==='column-stacked'));
  chart.update({ plotOptions:{ column:{ stacking: any ? 'normal' : null } } }, false);
}
let chart = Highcharts.stockChart('chart', {
  rangeSelector: { selected: 1 },
  title: { text: '' },
  credits: { enabled: false },
  legend: { enabled: true },
  tooltip: { shared: true, split: false },
  yAxis: [
    { title:{ text:'' }, opposite:false, alignTicks:true },
    { title:{ text:'' }, opposite:true,  alignTicks:true }
  ],
  plotOptions: { series: { turboThreshold: 0 }, column: { stacking: null } },
  series: []
});
function addSeriesToChart(name, data, uiType){
  const { actualType } = normalizeType(uiType);
  const yIdx = yAxisIndexForType(uiType||'spline');
  const s = chart.addSeries({ name, data, type: actualType, yAxis: yIdx }, false);
  s.update({ _uiType: (uiType||'spline') }, false);
  return s;
}
function replaceChartWithSeries(seriesList){
  while(chart.series.length) chart.series[0].remove(false);
  for(const s of seriesList) addSeriesToChart(s.name, s.data, s.type);
  applyGlobalStacking(); chart.redraw(); buildSeriesTable();
}
function snapshotChartSeries(){
  return chart.series.map(ser => ({
    name: ser.name,
    type: (ser.userOptions && ser.userOptions._uiType) ? ser.userOptions._uiType : ser.type,
    data: (ser.options && Array.isArray(ser.options.data) && ser.options.data.length)
      ? ser.options.data
      : ser.points?.map(p=>[p.x, p.y]) || []
  }));
}
function saveActiveFromChart(){
  const id = lsGet(ACTIVE_KEY); if(!id) return;
  const ds = getDataset(id); if(!ds) return;
  ds.series = snapshotChartSeries();
  ds.updatedAt = Date.now();
  try{ saveDataset(ds); }catch(e){ console.warn('Persist failed:', e); }
}

/* ================== UI: FAB + Panel ================== */
const panel = document.getElementById('panel');
document.getElementById('fab').addEventListener('click', ()=> panel.showModal());
document.getElementById('btnClose').addEventListener('click', ()=> panel.close());

/* ================== Inputs & actions ================== */
const el = id => document.getElementById(id);
const TYPE_OPTIONS = ['spline','line','area','areaspline','column','column-stacked'];

document.getElementById('fileInput').addEventListener('change', async (e)=>{
  const f=e.target.files?.[0]; if(!f) return;
  el('jsonInput').value = await f.text();
});

function defaults(){ return {
  datasetName: (el('datasetName').value.trim() || `Dataset ${new Date().toLocaleString()}`),
  defaultSeriesName: (el('defaultSeriesName').value.trim() || 'series')
};}

function tryParseAndReport(){
  const status = el('status'); status.textContent = '';
  const { defaultSeriesName } = defaults();
  const parsed = parseInput(el('jsonInput').value, defaultSeriesName);
  const n = parsed.reduce((a,s)=>a+(s.data?.length||0),0);
  status.textContent = `Parsed ${parsed.length} series, ${n} points.`;
  return parsed;
}

function persistAndActivate(list, datasetName){
  const ds = buildDatasetObject(datasetName, list);
  try{
    saveDataset(ds);
    lsSet(ACTIVE_KEY, ds.id);
    saveActiveFromChart();
    buildSeriesTable();
  }catch(e){
    alert('Saved in memory only (localStorage quota or write blocked). You can still export.');
  }
}

/* Buttons Add/Replace */
el('btnAdd').addEventListener('click', () => {
  try {
    const parsed = tryParseAndReport();
    const { datasetName } = defaults();
    const list = parsed.map(s=>({ ...s, type: s.type || 'spline' }));
    for(const s of list) addSeriesToChart(s.name, s.data, s.type);
    applyGlobalStacking(); chart.redraw();
    persistAndActivate(list, datasetName);
  } catch(e){ el('status').textContent = e.message; }
});
el('btnReplace').addEventListener('click', () => {
  try {
    const parsed = tryParseAndReport();
    const { datasetName } = defaults();
    const list = parsed.map(s=>({ ...s, type: s.type || 'spline' }));
    replaceChartWithSeries(list);
    persistAndActivate(list, datasetName);
  } catch(e){ el('status').textContent = e.message; }
});
el('btnClearInput').addEventListener('click', ()=>{ el('jsonInput').value=''; el('status').textContent=''; });

/* ================== Series table (editable) ================== */
function buildSeriesTable(){
  const wrap = document.getElementById('seriesTableWrap');
  if(!chart.series.length){ wrap.innerHTML = '<div class="muted">No series on chart.</div>'; return; }

  const tbl = document.createElement('table');
  const thead = document.createElement('thead');
  thead.innerHTML = `<tr><th>Name</th><th>Type</th><th></th></tr>`;
  const tbody = document.createElement('tbody');

  chart.series.forEach((s)=>{
    const tr = document.createElement('tr');

    const tdName = document.createElement('td');
    const nameInput = document.createElement('input');
    nameInput.type='text'; nameInput.value=s.name;
    nameInput.addEventListener('change', ()=>{ s.update({ name: nameInput.value }, false); chart.redraw(); saveActiveFromChart(); });
    tdName.appendChild(nameInput);

    const tdType = document.createElement('td');
    const selType = document.createElement('select');
    TYPE_OPTIONS.forEach(t=>{ const o=document.createElement('option'); o.value=t; o.textContent=t; selType.appendChild(o); });
    const uiType = s.userOptions && s.userOptions._uiType
      ? s.userOptions._uiType
      : (s.type==='column' && chart.options.plotOptions?.column?.stacking) ? 'column-stacked' : s.type;
    selType.value = uiType;
    selType.addEventListener('change', ()=>{
      const chosen = selType.value;
      const { actualType } = normalizeType(chosen);
      const yAxisIdx = yAxisIndexForType(chosen);
      s.update({ type: actualType, yAxis: yAxisIdx, _uiType: chosen }, false);
      applyGlobalStacking(); chart.redraw(); saveActiveFromChart();
    });
    tdType.appendChild(selType);

    const tdAct = document.createElement('td');
    const btnRemove = document.createElement('button'); btnRemove.textContent='Remove';
    btnRemove.addEventListener('click', ()=>{
      s.remove(false);
      applyGlobalStacking(); chart.redraw();
      buildSeriesTable(); saveActiveFromChart();
    });
    tdAct.appendChild(btnRemove);

    tr.append(tdName, tdType, tdAct);
    tbody.appendChild(tr);
  });

  tbl.append(thead, tbody);
  wrap.innerHTML = ''; wrap.appendChild(tbl);
}

/* ================== Saved datasets UI ================== */
function renderSavedList(){
  const container = document.getElementById('savedList');
  const metas = getAllMetas();
  if(!metas.length){ container.textContent='No saved datasets yet.'; return; }
  const active = lsGet(ACTIVE_KEY);

  const frag = document.createDocumentFragment();
  metas.forEach(m=>{
    const div=document.createElement('div');
    div.innerHTML = `<strong>${m.name}</strong> <span class="muted">(${m.count} series)</span>` + (m.id===active?' <span class="muted">• active</span>':'');
    const btnLoad=document.createElement('button'); btnLoad.textContent='Load';
    btnLoad.addEventListener('click', ()=>{
      const ds=getDataset(m.id); if(!ds) return;
      ds.series.forEach(sdef=>addSeriesToChart(sdef.name, sdef.data, sdef.type||'spline'));
      applyGlobalStacking(); chart.redraw(); lsSet(ACTIVE_KEY, m.id); saveActiveFromChart(); buildSeriesTable();
    });
    const btnDel=document.createElement('button'); btnDel.textContent='Delete';
    btnDel.addEventListener('click', ()=>{ if(confirm(`Delete "${m.name}"?`)) { deleteDataset(m.id); renderSavedList(); } });
    const row=document.createElement('div'); row.className='actions'; row.append(btnLoad, btnDel);
    div.appendChild(row); frag.appendChild(div);
  });
  container.innerHTML=''; container.appendChild(frag);
}

/* ================== Export / Import / Bulk load / Clear ================== */
document.getElementById('btnExportAll').addEventListener('click', ()=>{
  const ids=listIds(); const out={}; ids.forEach(id=>{ const ds=getDataset(id); if(ds) out[id]=ds; });
  const blob = new Blob([JSON.stringify(out, null, 2)], { type:'application/json' });
  const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='time_series_datasets.json'; a.click(); URL.revokeObjectURL(a.href);
});

document.getElementById('btnImportAll').addEventListener('click', ()=>document.getElementById('importAllInput').click());

document.getElementById('importAllInput').addEventListener('change', async (e)=>{
  const f=e.target.files?.[0]; if(!f) return;
  try{
    const text=await f.text();
    let obj; try{ obj=JSON.parse(text); }catch{ throw new Error('Invalid JSON'); }

    const baseName = (f.name||'import').replace(/\.[^.]+$/, '').replace(/[_\-]+/g,' ').trim();
    const datasets = datasetsFromAnyJson(obj, baseName);

    let ok=0, fail=0, quota=false;
    // Charge sur le graph AU FUR ET À MESURE, et tente d’enregistrer
    datasets.forEach(ds=>{
      (ds.series||[]).forEach(s=>addSeriesToChart(s.name, s.data, s.type||'spline'));
    });
    applyGlobalStacking(); chart.redraw(); buildSeriesTable();

    for (const ds of datasets){
      try{
        ds.updatedAt = Date.now(); if(!ds.savedAt) ds.savedAt = ds.updatedAt;
        saveDataset(ds); ok++; lsSet(ACTIVE_KEY, ds.id);
      }catch(e2){
        fail++; if(String(e2).toLowerCase().includes('quota')){ quota=true; break; }
      }
    }
    renderSavedList();
    if(fail===0){
      alert(`Imported ${ok} dataset(s).`);
    }else if(quota){
      alert(`Imported ${ok} dataset(s) to chart. Skipped ${fail} (localStorage quota). You can still Export.`);
    }else{
      alert(`Imported ${ok} dataset(s) to chart. Skipped ${fail} (write error/bad format).`);
    }
  }catch(err){
    alert('Import failed: '+(err?.message||err));
  }finally{
    e.target.value='';
  }
});

document.getElementById('btnLoadAllSaved').addEventListener('click', ()=>{
  const metas=getAllMetas(); if(!metas.length) return alert('No saved datasets.');
  metas.forEach(m=>{ const ds=getDataset(m.id); if(!ds) return; ds.series.forEach(sd=>addSeriesToChart(sd.name, sd.data, sd.type||'spline')); });
  applyGlobalStacking(); chart.redraw(); lsSet(ACTIVE_KEY, metas[0].id); saveActiveFromChart(); buildSeriesTable();
});

document.getElementById('btnClearAll').addEventListener('click', ()=>{
  if(!confirm('Delete ALL saved datasets in this browser?')) return;
  listIds().forEach(id=>deleteDataset(id));
  saveIndex([]); lsDel(ACTIVE_KEY);
  renderSavedList(); buildSeriesTable();
});

/* ================== Boot ================== */
renderSavedList();
buildSeriesTable();
</script>
</body>
</html>
