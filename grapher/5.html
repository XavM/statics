<!DOCTYPE html> 
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>TS Viewer</title>

<script src="https://code.highcharts.com/stock/highstock.js"></script>

<style>
  :root { --gap: 10px; --fab: 56px; --panel-w: 900px; }

  html, body { margin: 0; padding: 0; height: 100%; overflow: hidden; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; background: #fff; }

  #chartWrap { position: relative; width: 100vw; height: 100svh; min-height: 100svh; padding-top: env(safe-area-inset-top); padding-bottom: env(safe-area-inset-bottom); background: #fff; overflow: hidden; box-sizing: border-box; }
  #chart { width: 100%; height: 100%; min-height: 320px; }

  #fab { position: fixed; right: calc(16px + env(safe-area-inset-right)); bottom: calc(16px + env(safe-area-inset-bottom)); width: var(--fab); height: var(--fab); border-radius: 50%; border: none; box-shadow: 0 4px 12px rgba(0,0,0,.24); background: #1976d2; color: #fff; font-size: 28px; line-height: 1; cursor: pointer; z-index: 1000; }

  .panel { position: fixed; top: 0; right: 0; width: min(100vw, var(--panel-w)); max-width: 100vw; height: 100svh; min-height: 100svh; background: #fff; box-sizing: border-box; border-left: 1px solid #eee; transform: translateX(100%); transition: transform .25s ease; display: flex; flex-direction: column; z-index: 900; overflow: hidden; }
  .panel.open { transform: translateX(0); }

  .panel-head { display: flex; align-items: center; justify-content: space-between; padding: 12px 16px; border-bottom: 1px solid #eee; flex: 0 0 auto; }

  .panel-body { flex: 1 1 auto; overflow-y: auto; overflow-x: hidden; display: grid; }

  textarea, input[type="text"], select { width: 100%; padding: 8px; box-sizing: border-box; max-width: 100%; }
  textarea { min-height: 140px; resize: vertical; }
  .actions { display: flex; flex-wrap: wrap; gap: 8px; }
  .actions button { flex:1 1 auto; }
  button:not(#fab) { appearance:none; border:none; padding:10px 16px; border-radius:10px; background:#007aff; color:#fff; font-size:16px; cursor:pointer; }
  button.destructive { background:#ff3b30; }
  button.secondary { background:#fff; color:#007aff; border:1px solid #007aff; }
  .muted { color: #666; }
  .section-title { margin: 0; padding: 10px; position: sticky; top: 0; background: #fafafa; }

  table { width: 100%; border-collapse: collapse; table-layout: fixed; }
  th, td { text-align: left; padding: 8px; border-bottom: 1px solid #eee; }
  th { background: #fafafa; }
  td input, td select { width: 100%; box-sizing: border-box; }

  .dropzone { margin: 10px; border: 2px dashed #bbb; border-radius: 10px; padding: 28px; text-align: center; cursor: pointer; transition: border-color .15s ease, background .15s ease; background: #fafafa; }
  .dropzone.dragover { border-color: #1976d2; background: #eef4fb; }
</style>
</head>
<body>

<div id="chartWrap"><div id="chart"></div></div>

<button id="fab" title="Open/close controls" aria-controls="panel" aria-expanded="true">â‰¡</button>

<aside id="panel" class="panel" aria-label="Controls" aria-live="polite" tabindex="-1">
  <div class="panel-body">
    <section id="primaryArea"></section>

    <section aria-label="Saved datasets">
      <h3 class="section-title">Saved datasets</h3>
      <div id="savedList" class="muted">No saved datasets yet.</div>
      <div class="actions" style="margin:10px 0;">
        <button id="btnExportAll" type="button">Export all</button>
        <button id="btnImportAll" type="button">Import</button>
        <button id="btnLoadAllSaved" type="button">Load all</button>
        <button id="btnClearAll" class="destructive" type="button">Delete all</button>
        <input id="importAllInput" type="file" accept=".json" style="display:none" />
      </div>
    </section>

    <section aria-label="Grouping">
      <h3 class="section-title">Grouping</h3>
      <div style="padding:10px; display:flex; gap:10px; align-items:center;">
        <label for="groupUnit" class="muted">Granularity</label>
        <select id="groupUnit" style="max-width:200px;">
          <option value="auto" selected>auto</option>
          <option value="1m">1 minute</option>
          <option value="5m">5 minutes</option>
          <option value="1h">1 heure</option>
          <option value="1d">1 jour</option>
        </select>
      </div>
      <div id="groupingInfo" class="muted" style="padding:0 10px 10px"></div>
    </section>

    <section aria-label="Input">
      <h3 class="section-title">Input</h3>
      <input id="datasetName" type="text" placeholder="Dataset name" />
      <input id="defaultSeriesName" type="text" placeholder="Default series name (if missing)" />
      <input id="fileInput" type="file" accept=".json,.txt,application/json" style="display:none" />
      <textarea id="jsonInput" placeholder='JSON here (map or array of series). Keys "_meta"/"meta" ignored.'></textarea>
      <div class="actions">
        <button id="btnAdd" type="button">Add to chart</button>
        <button id="btnReplace" type="button">Replace chart</button>
        <button id="btnClearInput" type="button">Clear</button>
      </div>
      <div id="status" class="muted"></div>
    </section>

  </div>
</aside>
<script>
function getInset(side) {
  const div = document.createElement('div');
  div.style.cssText = `padding-${side}: env(safe-area-inset-${side});`;
  document.body.appendChild(div);
  const value = parseInt(getComputedStyle(div).getPropertyValue(`padding-${side}`)) || 0;
  div.remove();
  return value;
}

function notchSide() {
  const left = getInset('left');
  const right = getInset('right');
  if (left !== right) {
    return left > right ? 'gauche' : 'droite';
  }
  const o = window.orientation;
  if (o === 90) return 'gauche';
  if (o === -90) return 'droite';
  return null;
}

function applyNotchPadding() {
  const chartWrap = document.getElementById('chartWrap');
  const panel = document.getElementById('panel');
  const side = notchSide();
  const isLandscape = window.matchMedia('(orientation: landscape)').matches;

  chartWrap.style.paddingLeft = '';
  chartWrap.style.paddingRight = '';
  panel.style.paddingLeft = '';
  panel.style.paddingRight = '';

  if (isLandscape && side) {
    const inset = getInset(side === 'gauche' ? 'left' : 'right');
    const prop = side === 'gauche' ? 'paddingLeft' : 'paddingRight';
    chartWrap.style[prop] = inset + 'px';
    panel.style[prop] = inset + 'px';
  }
  if (typeof chart !== 'undefined' && chart && chart.reflow) chart.reflow();
}

window.addEventListener('load', applyNotchPadding);
window.addEventListener('orientationchange', () => setTimeout(applyNotchPadding, 50));
</script>

<script>
/* ====== localStorage granular ====== */
const INDEX_KEY  = 'ts_ds_index_v2';
const DS_PREFIX  = 'ts_ds_';
const ACTIVE_KEY = 'ts_active_dataset_id';

const lsGet = (k)=> localStorage.getItem(k);
const lsSet = (k,v)=> localStorage.setItem(k,v);
const lsDel = (k)=> localStorage.removeItem(k);

function loadIndex(){ try{ return JSON.parse(lsGet(INDEX_KEY)||'[]'); }catch{ return []; } }
function saveIndex(ids){ lsSet(INDEX_KEY, JSON.stringify(ids)); }
function listIds(){ return loadIndex(); }

function getDataset(id){ try{ const raw=lsGet(DS_PREFIX+id); return raw?JSON.parse(raw):null; }catch{ return null; } }
function saveDataset(ds){ lsSet(DS_PREFIX+ds.id, JSON.stringify(ds)); const ids=loadIndex(); if(!ids.includes(ds.id)){ ids.push(ds.id); saveIndex(ids); } }
function deleteDataset(id){ lsDel(DS_PREFIX+id); saveIndex(loadIndex().filter(x=>x!==id)); }
function getAllMetas(){ return listIds().map(id=>{ const ds=getDataset(id); return ds?{id, name:ds.name, updatedAt:ds.updatedAt||ds.savedAt||0, count:ds.series?.length||0}:null; }).filter(Boolean).sort((a,b)=>b.updatedAt-a.updatedAt); }

/* ====== Parse helpers ====== */
function toMillis(ts){ if (typeof ts === 'number') return ts < 1e12 ? Math.round(ts*1000) : Math.round(ts); const n = Number(ts); if (!Number.isNaN(n)) return n < 1e12 ? Math.round(n*1000) : Math.round(n); const d = Date.parse(ts); if(!Number.isNaN(d)) return d; throw new Error('Bad timestamp: '+ts); }
function normalizeDataArray(arr){ if(!Array.isArray(arr)) throw new Error('Series data must be an array'); if(!arr.length) return []; if(Array.isArray(arr[0])) return arr.map(p=>[toMillis(p[0]), Number(p[1])]); return arr.map(p=>[toMillis(p.timestamp??p.time??p.t), Number(p.value??p.v)]); }
function parseInput(text, defaultName){ const obj = JSON.parse(text); if(obj && typeof obj==='object' && !Array.isArray(obj)){ const out=[]; for(const [name,data] of Object.entries(obj)){ if(name==='_meta'||name==='meta') continue; out.push({ name, data: normalizeDataArray(data) }); } return out; } if(Array.isArray(obj)){ if(obj.length && typeof obj[0]==='object' && !Array.isArray(obj[0]) && ('name' in obj[0] || 'data' in obj[0])){ return obj.map((s,i)=>({ name: s.name ?? `${defaultName||'series'} ${i+1}`, data: normalizeDataArray(s.data ?? s.values ?? s.series ?? []) })); } return [{ name: defaultName || ('series '+new Date().toISOString()), data: normalizeDataArray(obj) }]; } throw new Error('Unsupported JSON'); }

/* ====== Build dataset(s) from ANY JSON ====== */
function buildDatasetObject(name, seriesList){ return { id:`${Date.now()}_${Math.random().toString(36).slice(2,8)}`, name, savedAt: Date.now(), updatedAt: Date.now(), series: seriesList.map(s=>({ name:s.name, type:s.type||'spline', agg:s.agg||'auto', data:s.data })) }; }
function datasetsFromAnyJson(obj, nameHint){ const makeId = () => `${Date.now()}_${Math.random().toString(36).slice(2,8)}`; if (obj && typeof obj==='object' && !Array.isArray(obj) && Array.isArray(obj.series)) { const ds = { ...obj }; if (!ds.id) ds.id = makeId(); if (!ds.name) ds.name = nameHint || 'Imported dataset'; return [ds]; } if (obj && typeof obj==='object' && !Array.isArray(obj)) { const vals = Object.values(obj); if (vals.length && vals.every(v => v && typeof v==='object' && Array.isArray(v.series))) { return vals.map(v => ({ ...v, id: v.id || makeId(), name: v.name || nameHint || 'Imported dataset' })); } const parsed = parseInput(JSON.stringify(obj), 'series'); const list = parsed.map(s=>({ name:s.name, type:s.type||'spline', data:s.data })); return [buildDatasetObject(nameHint || `Imported ${new Date().toLocaleString()}`, list)]; } if (Array.isArray(obj)) { if (obj.length && obj[0] && typeof obj[0]==='object' && Array.isArray(obj[0].series)) { return obj.map(v => ({ ...v, id: v.id || makeId(), name: v.name || nameHint || 'Imported dataset' })); } const parsed = parseInput(JSON.stringify(obj), 'series'); const list = parsed.map(s=>({ name:s.name, type:s.type||'spline', data:s.data })); return [buildDatasetObject(nameHint || `Imported ${new Date().toLocaleString()}`, list)]; } throw new Error('Unsupported JSON'); }

/* ====== Aggregation + Group-units ====== */
const GROUP_UNITS = { '1m': [['minute', [1]]], '5m': [['minute', [5]]], '1h': [['hour', [1]]], '1d': [['day', [1]]] };
let currentGroupKey = 'auto';

function approximationFor(agg){ if (agg === 'sum') return 'sum'; if (agg === 'average') return 'average'; if (agg === 'min') return 'low'; if (agg === 'max') return 'high'; if (agg === 'count') return function (arr){ if (!arr) return 0; let n = 0; for (let i=0;i<arr.length;i++){ const v = arr[i]; if (v != null && !Number.isNaN(v)) n++; } return n; }; return null; }

function setSeriesAggregation(series, agg){ series.update({ _agg: agg }, false); if (agg === 'none'){ series.update({ dataGrouping: { enabled: false } }, false); return; } const dg = { enabled: true }; if (agg !== 'auto'){ const approx = approximationFor(agg); dg.approximation = approx; } if (currentGroupKey !== 'auto'){ dg.units = GROUP_UNITS[currentGroupKey]; dg.forced = true; } else { dg.forced = false; } series.update({ dataGrouping: dg }, false); }

function applyGroupingUnitsToAllSeries(){ userSeries().forEach(s=>{ const agg = (s.userOptions && s.userOptions._agg) || 'auto'; if (agg === 'none') return; const dg = { enabled: true }; if (agg !== 'auto'){ const approx = approximationFor(agg); dg.approximation = approx; } if (currentGroupKey !== 'auto'){ dg.units = GROUP_UNITS[currentGroupKey]; dg.forced = true; } else { dg.forced = false; } s.update({ dataGrouping: dg }, false); }); chart.redraw(); saveActiveFromChart(); }

/* ====== Chart ====== */
function yAxisIndexForType(uiType){ return (uiType==='column'||uiType==='column-stacked') ? 0 : 1; }
function normalizeType(t){ return (t==='column-stacked') ? { actualType:'column', stacked:true } : { actualType:(t||'spline'), stacked:false }; }
function applyGlobalStacking(){ const any = userSeries().some(s=> (s.userOptions && s.userOptions._uiType==='column-stacked')); chart.update({ plotOptions:{ column:{ stacking: any ? 'normal' : null } } }, false); }

let chart;

function updateAggBadge(){
  let badge = document.getElementById('aggBadge');
  if(!badge){
    badge = document.createElement('div');
    badge.id = 'aggBadge';
    badge.style.cssText = 'position:absolute;top:8px;right:8px;background:#007aff;color:#fff;padding:2px 6px;border-radius:12px;font-size:12px;line-height:1;z-index:10;pointer-events:none;';
    document.getElementById('chartWrap').appendChild(badge);
  }
  const s = chart.series && chart.series.find? chart.series.find(x=>x.name !== 'Navigator 1') : null;
  const g = s && s.currentDataGrouping;
  if(g){
    const unitMap = { millisecond:'ms', second:'s', minute:'m', hour:'h', day:'d', week:'w', month:'M', year:'y' };
    const count = g.count || 1;
    const unit = unitMap[g.unitName] || g.unitName;
    badge.textContent = `${count}${unit}`;
    badge.style.display = 'block';
  } else {
    badge.style.display = 'none';
  }
}

function updateGroupingInfo(){
  const info = document.getElementById('groupingInfo');
  if(!info || !chart) return;
  const s = chart.series && chart.series.find? chart.series.find(x=>x.name !== 'Navigator 1') : null;
  const g = s && s.currentDataGrouping;
  if(g){
    const count = g.count || 1;
    info.textContent = `Current grouping: ${count} ${g.unitName}${count>1?'s':''}`;
  } else {
    info.textContent = 'Current grouping: none';
  }
  updateAggBadge();
}

chart = Highcharts.stockChart('chart', {
  chart: { spacingLeft: 8, spacingRight: 22, events:{ redraw: updateGroupingInfo } },
  rangeSelector: {
    selected: 1,
    inputDateFormat: '%Y-%m-%d %H:%M',
    inputEditDateFormat: '%Y-%m-%d %H:%M',
    inputBoxWidth: 110,
    labelStyle: { display: 'none' }
  },
  xAxis: { events:{ afterSetExtremes: updateGroupingInfo } },
  title: { text: '' },
  credits: { enabled: false },
  legend: { enabled: true },
  tooltip: { shared: true, split: false },
  yAxis: [ { title:{ text:'' }, opposite:false, alignTicks:true, labels: { align: 'right', x: -6, reserveSpace: true }, offset: 6 }, { title:{ text:'' }, opposite:true, alignTicks:true, labels: { align: 'left', x: 4, reserveSpace: true }, offset: 6 } ],
  plotOptions: { series: { turboThreshold: 0 }, column: { stacking: null } },
  series: []
});
updateGroupingInfo();
const userSeries = () => chart.series.filter(s => s.name !== 'Navigator 1');

const baseNavHeight = chart.options.navigator && chart.options.navigator.height || 40;
function adjustNavigatorHeight(){
  const isLandscape = window.innerWidth > window.innerHeight;
  const h = isLandscape ? baseNavHeight * 0.7 : baseNavHeight;
  chart.update({ navigator:{ height: h } }, false);
  chart.redraw();
}
window.addEventListener('resize', adjustNavigatorHeight);
adjustNavigatorHeight();

function addSeriesToChart(name, data, uiType, agg='auto'){ const { actualType } = normalizeType(uiType); const yIdx = yAxisIndexForType(uiType||'spline'); const s = chart.addSeries({ name, data, type: actualType, yAxis: yIdx }, false); s.update({ _uiType: (uiType||'spline') }, false); setSeriesAggregation(s, agg || 'auto'); return s; }
function replaceChartWithSeries(seriesList){ while(chart.series.length) chart.series[0].remove(false); for(const s of seriesList) addSeriesToChart(s.name, s.data, s.type, s.agg||'auto'); applyGlobalStacking(); chart.redraw(); buildSeriesTable(); updatePrimaryArea(); }
function snapshotChartSeries(){ return userSeries().map(ser => ({ name: ser.name, type: (ser.userOptions && ser.userOptions._uiType) ? ser.userOptions._uiType : ser.type, agg:  (ser.userOptions && ser.userOptions._agg) ? ser.userOptions._agg : 'auto', data: (ser.options && Array.isArray(ser.options.data) && ser.options.data.length) ? ser.options.data : ser.points?.map(p=>[p.x, p.y]) || [] })); }
function saveActiveFromChart(){ const id = lsGet(ACTIVE_KEY); if(!id) return; const ds = getDataset(id); if(!ds) return; ds.series = snapshotChartSeries(); ds.updatedAt = Date.now(); try{ saveDataset(ds); }catch(e){ console.warn('Persist failed:', e); } }

/* ====== UI: FAB + Panel ====== */
const panel = document.getElementById('panel');
const fab   = document.getElementById('fab');
function togglePanel(){ const willOpen = !panel.classList.contains('open'); panel.classList.toggle('open'); fab.setAttribute('aria-expanded', String(willOpen)); if (willOpen) panel.focus(); }
fab.addEventListener('click', togglePanel);
window.addEventListener('keydown', (e)=>{ if(e.key==='Escape' && panel.classList.contains('open')) togglePanel(); });

/* ====== Inputs & actions ====== */
const el = id => document.getElementById(id);
const TYPE_OPTIONS = ['spline','line','area','areaspline','column','column-stacked'];
const AGG_OPTIONS  = ['auto','none','count','sum','average','min','max'];

document.getElementById('fileInput').addEventListener('change', async (e)=>{ const f=e.target.files?.[0]; if(!f) return; await handleFileImport(f, {alsoLoad:true, showAlert:true}); });

function defaults(){ return { datasetName: (el('datasetName').value.trim() || `Dataset ${new Date().toLocaleString()}`), defaultSeriesName: (el('defaultSeriesName').value.trim() || 'series') }; }

function tryParseAndReport(){ const status = el('status'); status.textContent = ''; const { defaultSeriesName } = defaults(); const parsed = parseInput(el('jsonInput').value, defaultSeriesName); const n = parsed.reduce((a,s)=>a+(s.data?.length||0),0); status.textContent = `Parsed ${parsed.length} series, ${n} points.`; return parsed; }

function persistAndActivate(list, datasetName){ const ds = buildDatasetObject(datasetName, list); try{ saveDataset(ds); lsSet(ACTIVE_KEY, ds.id); saveActiveFromChart(); buildSeriesTable(); renderSavedList(); }catch(e){ alert('Saved in memory only (localStorage quota or write blocked). You can still export.'); } }

el('btnAdd').addEventListener('click', () => { try { const parsed = tryParseAndReport(); const { datasetName } = defaults(); const list = parsed.map(s=>({ ...s, type: s.type || 'spline', agg: s.agg || 'auto' })); for(const s of list) addSeriesToChart(s.name, s.data, s.type, s.agg); applyGlobalStacking(); chart.redraw(); persistAndActivate(list, datasetName); updatePrimaryArea(); } catch(e){ el('status').textContent = e.message; } });
el('btnReplace').addEventListener('click', () => { try { const parsed = tryParseAndReport(); const { datasetName } = defaults(); const list = parsed.map(s=>({ ...s, type: s.type || 'spline', agg: s.agg || 'auto' })); replaceChartWithSeries(list); persistAndActivate(list, datasetName); } catch(e){ el('status').textContent = e.message; } });
el('btnClearInput').addEventListener('click', ()=>{ el('jsonInput').value=''; el('status').textContent=''; });

/* ====== Primary area ====== */
function updatePrimaryArea(){ const primary = document.getElementById('primaryArea'); primary.innerHTML = ''; const series = userSeries(); if (!series.length) { const dz = document.createElement('div'); dz.className = 'dropzone'; dz.innerHTML = `
      <div style="font-weight:600; margin-bottom:6px;">Drop your JSON file here</div>
      <div class="muted" style="margin-bottom:8px;">Map/array of series (keys "_meta"/"meta" ignored)</div>
      <div><a href="#" id="manualUploadLink">or click to select a file</a></div>
    `; const fileInput = document.getElementById('fileInput'); dz.addEventListener('click', ()=> fileInput.click()); dz.addEventListener('dragover', (e)=>{ e.preventDefault(); dz.classList.add('dragover'); }); dz.addEventListener('dragleave', ()=> dz.classList.remove('dragover')); dz.addEventListener('drop', (e)=>{ e.preventDefault(); dz.classList.remove('dragover'); const f = e.dataTransfer.files && e.dataTransfer.files[0]; if(!f) return; handleFileImport(f, {alsoLoad:true, showAlert:true}); }); dz.querySelector('#manualUploadLink').addEventListener('click', (e)=>{ e.preventDefault(); fileInput.click(); }); primary.appendChild(dz); } else { const title = document.createElement('h3'); title.className = 'section-title'; title.textContent = 'Series'; primary.appendChild(title); const wrap = document.createElement('div'); wrap.id = 'seriesTableWrap'; primary.appendChild(wrap); buildSeriesTable(); } }

/* ====== Series table ====== */
function buildSeriesTable(){ const wrap = document.getElementById('seriesTableWrap') || document.getElementById('primaryArea'); const list = userSeries(); if(!list.length){ wrap.innerHTML = '<div class="muted">No series on chart.</div>'; return; } const tbl = document.createElement('table'); const thead = document.createElement('thead'); thead.innerHTML = `<tr><th>Name</th><th>Type</th><th>Aggregation</th><th></th></tr>`; const tbody = document.createElement('tbody'); list.forEach((s)=>{ const tr = document.createElement('tr'); const tdName = document.createElement('td'); const nameInput = document.createElement('input'); nameInput.type='text'; nameInput.value=s.name; nameInput.addEventListener('change', ()=>{ s.update({ name: nameInput.value }, false); chart.redraw(); saveActiveFromChart(); }); tdName.appendChild(nameInput); const tdType = document.createElement('td'); const selType = document.createElement('select'); TYPE_OPTIONS.forEach(t=>{ const o=document.createElement('option'); o.value=t; o.textContent=t; selType.appendChild(o); }); const uiType = s.userOptions && s.userOptions._uiType ? s.userOptions._uiType : (s.type==='column' && chart.options.plotOptions?.column?.stacking) ? 'column-stacked' : s.type; selType.value = uiType; selType.addEventListener('change', ()=>{ const chosen = selType.value; const { actualType } = normalizeType(chosen); const yAxisIdx = yAxisIndexForType(chosen); s.update({ type: actualType, yAxis: yAxisIdx, _uiType: chosen }, false); applyGlobalStacking(); chart.redraw(); saveActiveFromChart(); }); tdType.appendChild(selType); const tdAgg = document.createElement('td'); const selAgg = document.createElement('select'); AGG_OPTIONS.forEach(a=>{ const o=document.createElement('option'); o.value=a; o.textContent=a; selAgg.appendChild(o); }); selAgg.value = (s.userOptions && s.userOptions._agg) ? s.userOptions._agg : 'auto'; selAgg.addEventListener('change', ()=>{ setSeriesAggregation(s, selAgg.value); chart.redraw(); saveActiveFromChart(); }); tdAgg.appendChild(selAgg); const tdAct = document.createElement('td'); const iconRemove = document.createElement('span'); iconRemove.textContent='ðŸ—‘ï¸'; iconRemove.style.cursor='pointer'; iconRemove.addEventListener('click', ()=>{ s.remove(false); applyGlobalStacking(); chart.redraw(); buildSeriesTable(); saveActiveFromChart(); updatePrimaryArea(); }); tdAct.appendChild(iconRemove); tr.append(tdName, tdType, tdAgg, tdAct); tbody.appendChild(tr); }); tbl.append(thead, tbody); wrap.innerHTML = ''; wrap.appendChild(tbl); }

/* ====== Saved datasets UI ====== */
function renderSavedList(){ const container = document.getElementById('savedList'); const metas = getAllMetas(); if(!metas.length){ container.textContent='No saved datasets yet.'; return; } const active = lsGet(ACTIVE_KEY); const frag = document.createDocumentFragment(); metas.forEach(m=>{ const div=document.createElement('div'); const strong = document.createElement('strong'); strong.textContent = m.name; const span1 = document.createElement('span'); span1.className='muted'; span1.textContent = ` (${m.count} series)`; div.appendChild(strong); div.appendChild(document.createTextNode(' ')); div.appendChild(span1); if(m.id===active){ const activeSpan=document.createElement('span'); activeSpan.className='muted'; activeSpan.textContent=' â€¢ active'; div.appendChild(document.createTextNode(' ')); div.appendChild(activeSpan); } const row=document.createElement('div'); row.className='actions'; const btnLoad=document.createElement('button'); btnLoad.textContent='Load'; btnLoad.addEventListener('click', ()=>{ const ds=getDataset(m.id); if(!ds) return; (ds.series||[]).forEach(sdef=>addSeriesToChart(sdef.name, sdef.data, sdef.type||'spline', sdef.agg||'auto')); applyGlobalStacking(); chart.redraw(); lsSet(ACTIVE_KEY, m.id); saveActiveFromChart(); updatePrimaryArea(); }); const btnDel=document.createElement('button'); btnDel.className='destructive'; btnDel.textContent='Delete'; btnDel.addEventListener('click', ()=>{ if(confirm(`Delete "${m.name}"?`)) { deleteDataset(m.id); renderSavedList(); } }); row.append(btnLoad, btnDel); div.appendChild(row); frag.appendChild(div); }); container.innerHTML=''; container.appendChild(frag); }

/* ====== Import/Export/Clear ====== */
document.getElementById('btnExportAll').addEventListener('click', ()=>{ const ids=listIds(); const out={}; ids.forEach(id=>{ const ds=getDataset(id); if(ds) out[id]=ds; }); const blob = new Blob([JSON.stringify(out, null, 2)], { type:'application/json' }); const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='time_series_datasets.json'; a.click(); URL.revokeObjectURL(a.href); });
document.getElementById('btnImportAll').addEventListener('click', ()=>document.getElementById('importAllInput').click());
document.getElementById('importAllInput').addEventListener('change', async (e)=>{ const f=e.target.files?.[0]; if(!f) return; await handleFileImport(f, {alsoLoad:true, showAlert:true}); e.target.value=''; });
document.getElementById('btnLoadAllSaved').addEventListener('click', ()=>{ const metas=getAllMetas(); if(!metas.length) return alert('No saved datasets.'); metas.forEach(m=>{ const ds=getDataset(m.id); if(!ds) return; (ds.series||[]).forEach(sd=>addSeriesToChart(sd.name, sd.data, sd.type||'spline', sd.agg||'auto')); }); applyGlobalStacking(); chart.redraw(); lsSet(ACTIVE_KEY, metas[0].id); saveActiveFromChart(); updatePrimaryArea(); });
document.getElementById('btnClearAll').addEventListener('click', ()=>{ if(!confirm('Delete ALL saved datasets in this browser?')) return; listIds().forEach(id=>deleteDataset(id)); saveIndex([]); lsDel(ACTIVE_KEY); renderSavedList(); updatePrimaryArea(); });

/* ====== Import core ====== */
async function handleFileImport(file, opts={alsoLoad:true, showAlert:true}){ try{ const text = await file.text(); let obj; try{ obj = JSON.parse(text); }catch{ throw new Error('Invalid JSON'); } const baseName = (file.name||'import').replace(/\.[^.]+$/, '').replace(/[_\-]+/g,' ').trim(); const datasets = datasetsFromAnyJson(obj, baseName); let ok=0, fail=0, quota=false; if (opts.alsoLoad){ datasets.forEach(ds=>{ (ds.series||[]).forEach(s=>addSeriesToChart(s.name, s.data, s.type||'spline', s.agg||'auto')); }); applyGlobalStacking(); chart.redraw(); buildSeriesTable(); updatePrimaryArea(); } for (const ds of datasets){ try{ ds.updatedAt = Date.now(); if(!ds.savedAt) ds.savedAt = ds.updatedAt; saveDataset(ds); ok++; lsSet(ACTIVE_KEY, ds.id); }catch(e2){ fail++; if(String(e2).toLowerCase().includes('quota')){ quota=true; break; } } } renderSavedList(); if(opts.showAlert){ if(fail===0) alert(`Imported ${ok} dataset(s).`); else if(quota) alert(`Imported ${ok} dataset(s) to chart. Skipped ${fail} (localStorage quota). You can still Export.`); else alert(`Imported ${ok} dataset(s) to chart. Skipped ${fail} (write error/bad format).`); } }catch(err){ if(opts.showAlert) alert('Import failed: ' + (err?.message || err)); } }

/* ====== Grouping selector wiring ====== */
const groupUnitSel = document.getElementById('groupUnit');
if (groupUnitSel){ groupUnitSel.addEventListener('change', (e)=>{ currentGroupKey = e.target.value || 'auto'; applyGroupingUnitsToAllSeries(); }); }

/* ====== Boot ====== */
renderSavedList();
updatePrimaryArea();
panel.classList.add('open');
</script>
</body>
</html>
